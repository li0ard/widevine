/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 6.30.2
 * source: license_protocol.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
// @ts-nocheck
import * as pb_1 from "google-protobuf";
export namespace pywidevine_license_protocol {
    export enum LicenseType {
        STREAMING = 1,
        OFFLINE = 2,
        AUTOMATIC = 3
    }
    export enum PlatformVerificationStatus {
        PLATFORM_UNVERIFIED = 0,
        PLATFORM_TAMPERED = 1,
        PLATFORM_SOFTWARE_VERIFIED = 2,
        PLATFORM_HARDWARE_VERIFIED = 3,
        PLATFORM_NO_VERIFICATION = 4,
        PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED = 5
    }
    export enum ProtocolVersion {
        VERSION_2_0 = 20,
        VERSION_2_1 = 21,
        VERSION_2_2 = 22
    }
    export enum HashAlgorithmProto {
        HASH_ALGORITHM_UNSPECIFIED = 0,
        HASH_ALGORITHM_SHA_1 = 1,
        HASH_ALGORITHM_SHA_256 = 2,
        HASH_ALGORITHM_SHA_384 = 3
    }
    export class LicenseIdentification extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            request_id?: Uint8Array;
            session_id?: Uint8Array;
            purchase_id?: Uint8Array;
            type?: LicenseType;
            version?: number;
            provider_session_token?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("request_id" in data && data.request_id != undefined) {
                    this.request_id = data.request_id;
                }
                if ("session_id" in data && data.session_id != undefined) {
                    this.session_id = data.session_id;
                }
                if ("purchase_id" in data && data.purchase_id != undefined) {
                    this.purchase_id = data.purchase_id;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("version" in data && data.version != undefined) {
                    this.version = data.version;
                }
                if ("provider_session_token" in data && data.provider_session_token != undefined) {
                    this.provider_session_token = data.provider_session_token;
                }
            }
        }
        get request_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set request_id(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_request_id() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get session_id() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set session_id(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get has_session_id() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get purchase_id() {
            return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
        }
        set purchase_id(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        get has_purchase_id() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 4, LicenseType.STREAMING) as LicenseType;
        }
        set type(value: LicenseType) {
            pb_1.Message.setField(this, 4, value);
        }
        get has_type() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get version() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set version(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get has_version() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get provider_session_token() {
            return pb_1.Message.getFieldWithDefault(this, 6, new Uint8Array(0)) as Uint8Array;
        }
        set provider_session_token(value: Uint8Array) {
            pb_1.Message.setField(this, 6, value);
        }
        get has_provider_session_token() {
            return pb_1.Message.getField(this, 6) != null;
        }
        static fromObject(data: {
            request_id?: Uint8Array;
            session_id?: Uint8Array;
            purchase_id?: Uint8Array;
            type?: LicenseType;
            version?: number;
            provider_session_token?: Uint8Array;
        }): LicenseIdentification {
            const message = new LicenseIdentification({});
            if (data.request_id != null) {
                message.request_id = data.request_id;
            }
            if (data.session_id != null) {
                message.session_id = data.session_id;
            }
            if (data.purchase_id != null) {
                message.purchase_id = data.purchase_id;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.version != null) {
                message.version = data.version;
            }
            if (data.provider_session_token != null) {
                message.provider_session_token = data.provider_session_token;
            }
            return message;
        }
        toObject() {
            const data: {
                request_id?: Uint8Array;
                session_id?: Uint8Array;
                purchase_id?: Uint8Array;
                type?: LicenseType;
                version?: number;
                provider_session_token?: Uint8Array;
            } = {};
            if (this.request_id != null) {
                data.request_id = this.request_id;
            }
            if (this.session_id != null) {
                data.session_id = this.session_id;
            }
            if (this.purchase_id != null) {
                data.purchase_id = this.purchase_id;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.version != null) {
                data.version = this.version;
            }
            if (this.provider_session_token != null) {
                data.provider_session_token = this.provider_session_token;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_request_id && this.request_id.length)
                writer.writeBytes(1, this.request_id);
            if (this.has_session_id && this.session_id.length)
                writer.writeBytes(2, this.session_id);
            if (this.has_purchase_id && this.purchase_id.length)
                writer.writeBytes(3, this.purchase_id);
            if (this.has_type)
                writer.writeEnum(4, this.type);
            if (this.has_version)
                writer.writeInt32(5, this.version);
            if (this.has_provider_session_token && this.provider_session_token.length)
                writer.writeBytes(6, this.provider_session_token);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LicenseIdentification {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LicenseIdentification();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.request_id = reader.readBytes();
                        break;
                    case 2:
                        message.session_id = reader.readBytes();
                        break;
                    case 3:
                        message.purchase_id = reader.readBytes();
                        break;
                    case 4:
                        message.type = reader.readEnum();
                        break;
                    case 5:
                        message.version = reader.readInt32();
                        break;
                    case 6:
                        message.provider_session_token = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LicenseIdentification {
            return LicenseIdentification.deserialize(bytes);
        }
    }
    export class License extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: LicenseIdentification;
            policy?: License.Policy;
            key: License.KeyContainer[];
            license_start_time?: number;
            remote_attestation_verified?: boolean;
            provider_client_token?: Uint8Array;
            protection_scheme?: number;
            srm_requirement?: Uint8Array;
            srm_update?: Uint8Array;
            platform_verification_status?: PlatformVerificationStatus;
            group_ids: Uint8Array[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3, 11], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("policy" in data && data.policy != undefined) {
                    this.policy = data.policy;
                }
                this.key = data.key;
                if ("license_start_time" in data && data.license_start_time != undefined) {
                    this.license_start_time = data.license_start_time;
                }
                if ("remote_attestation_verified" in data && data.remote_attestation_verified != undefined) {
                    this.remote_attestation_verified = data.remote_attestation_verified;
                }
                if ("provider_client_token" in data && data.provider_client_token != undefined) {
                    this.provider_client_token = data.provider_client_token;
                }
                if ("protection_scheme" in data && data.protection_scheme != undefined) {
                    this.protection_scheme = data.protection_scheme;
                }
                if ("srm_requirement" in data && data.srm_requirement != undefined) {
                    this.srm_requirement = data.srm_requirement;
                }
                if ("srm_update" in data && data.srm_update != undefined) {
                    this.srm_update = data.srm_update;
                }
                if ("platform_verification_status" in data && data.platform_verification_status != undefined) {
                    this.platform_verification_status = data.platform_verification_status;
                }
                this.group_ids = data.group_ids;
            }
        }
        get id() {
            return pb_1.Message.getWrapperField(this, LicenseIdentification, 1) as LicenseIdentification;
        }
        set id(value: LicenseIdentification) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_id() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get policy() {
            return pb_1.Message.getWrapperField(this, License.Policy, 2) as License.Policy;
        }
        set policy(value: License.Policy) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_policy() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get key() {
            return pb_1.Message.getRepeatedWrapperField(this, License.KeyContainer, 3) as License.KeyContainer[];
        }
        set key(value: License.KeyContainer[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        get license_start_time() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set license_start_time(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get has_license_start_time() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get remote_attestation_verified() {
            return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
        }
        set remote_attestation_verified(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        get has_remote_attestation_verified() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get provider_client_token() {
            return pb_1.Message.getFieldWithDefault(this, 6, new Uint8Array(0)) as Uint8Array;
        }
        set provider_client_token(value: Uint8Array) {
            pb_1.Message.setField(this, 6, value);
        }
        get has_provider_client_token() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get protection_scheme() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set protection_scheme(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get has_protection_scheme() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get srm_requirement() {
            return pb_1.Message.getFieldWithDefault(this, 8, new Uint8Array(0)) as Uint8Array;
        }
        set srm_requirement(value: Uint8Array) {
            pb_1.Message.setField(this, 8, value);
        }
        get has_srm_requirement() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get srm_update() {
            return pb_1.Message.getFieldWithDefault(this, 9, new Uint8Array(0)) as Uint8Array;
        }
        set srm_update(value: Uint8Array) {
            pb_1.Message.setField(this, 9, value);
        }
        get has_srm_update() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get platform_verification_status() {
            return pb_1.Message.getFieldWithDefault(this, 10, PlatformVerificationStatus.PLATFORM_NO_VERIFICATION) as PlatformVerificationStatus;
        }
        set platform_verification_status(value: PlatformVerificationStatus) {
            pb_1.Message.setField(this, 10, value);
        }
        get has_platform_verification_status() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get group_ids() {
            return pb_1.Message.getFieldWithDefault(this, 11, []) as Uint8Array[];
        }
        set group_ids(value: Uint8Array[]) {
            pb_1.Message.setField(this, 11, value);
        }
        static fromObject(data: {
            id?: ReturnType<typeof LicenseIdentification.prototype.toObject>;
            policy?: ReturnType<typeof License.Policy.prototype.toObject>;
            key?: ReturnType<typeof License.KeyContainer.prototype.toObject>[];
            license_start_time?: number;
            remote_attestation_verified?: boolean;
            provider_client_token?: Uint8Array;
            protection_scheme?: number;
            srm_requirement?: Uint8Array;
            srm_update?: Uint8Array;
            platform_verification_status?: PlatformVerificationStatus;
            group_ids: Uint8Array[];
        }): License {
            const message = new License({
                key: data.key.map(item => License.KeyContainer.fromObject(item)),
                group_ids: data.group_ids
            });
            if (data.id != null) {
                message.id = LicenseIdentification.fromObject(data.id);
            }
            if (data.policy != null) {
                message.policy = License.Policy.fromObject(data.policy);
            }
            if (data.license_start_time != null) {
                message.license_start_time = data.license_start_time;
            }
            if (data.remote_attestation_verified != null) {
                message.remote_attestation_verified = data.remote_attestation_verified;
            }
            if (data.provider_client_token != null) {
                message.provider_client_token = data.provider_client_token;
            }
            if (data.protection_scheme != null) {
                message.protection_scheme = data.protection_scheme;
            }
            if (data.srm_requirement != null) {
                message.srm_requirement = data.srm_requirement;
            }
            if (data.srm_update != null) {
                message.srm_update = data.srm_update;
            }
            if (data.platform_verification_status != null) {
                message.platform_verification_status = data.platform_verification_status;
            }
            return message;
        }
        toObject() {
            const data: {
                id?: ReturnType<typeof LicenseIdentification.prototype.toObject>;
                policy?: ReturnType<typeof License.Policy.prototype.toObject>;
                key?: ReturnType<typeof License.KeyContainer.prototype.toObject>[];
                license_start_time?: number;
                remote_attestation_verified?: boolean;
                provider_client_token?: Uint8Array;
                protection_scheme?: number;
                srm_requirement?: Uint8Array;
                srm_update?: Uint8Array;
                platform_verification_status?: PlatformVerificationStatus;
                group_ids: Uint8Array[];
            } = {
                group_ids: this.group_ids
            };
            if (this.id != null) {
                data.id = this.id.toObject();
            }
            if (this.policy != null) {
                data.policy = this.policy.toObject();
            }
            if (this.key != null) {
                data.key = this.key.map((item: License.KeyContainer) => item.toObject());
            }
            if (this.license_start_time != null) {
                data.license_start_time = this.license_start_time;
            }
            if (this.remote_attestation_verified != null) {
                data.remote_attestation_verified = this.remote_attestation_verified;
            }
            if (this.provider_client_token != null) {
                data.provider_client_token = this.provider_client_token;
            }
            if (this.protection_scheme != null) {
                data.protection_scheme = this.protection_scheme;
            }
            if (this.srm_requirement != null) {
                data.srm_requirement = this.srm_requirement;
            }
            if (this.srm_update != null) {
                data.srm_update = this.srm_update;
            }
            if (this.platform_verification_status != null) {
                data.platform_verification_status = this.platform_verification_status;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_id)
                writer.writeMessage(1, this.id, () => this.id.serialize(writer));
            if (this.has_policy)
                writer.writeMessage(2, this.policy, () => this.policy.serialize(writer));
            if (this.key.length)
                writer.writeRepeatedMessage(3, this.key, (item: License.KeyContainer) => item.serialize(writer));
            if (this.has_license_start_time)
                writer.writeInt64(4, this.license_start_time);
            if (this.has_remote_attestation_verified)
                writer.writeBool(5, this.remote_attestation_verified);
            if (this.has_provider_client_token && this.provider_client_token.length)
                writer.writeBytes(6, this.provider_client_token);
            if (this.has_protection_scheme)
                writer.writeUint32(7, this.protection_scheme);
            if (this.has_srm_requirement && this.srm_requirement.length)
                writer.writeBytes(8, this.srm_requirement);
            if (this.has_srm_update && this.srm_update.length)
                writer.writeBytes(9, this.srm_update);
            if (this.has_platform_verification_status)
                writer.writeEnum(10, this.platform_verification_status);
            if (this.group_ids.length)
                writer.writeRepeatedBytes(11, this.group_ids);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): License {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new License();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.id, () => message.id = LicenseIdentification.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.policy, () => message.policy = License.Policy.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.key, () => pb_1.Message.addToRepeatedWrapperField(message, 3, License.KeyContainer.deserialize(reader), License.KeyContainer));
                        break;
                    case 4:
                        message.license_start_time = reader.readInt64();
                        break;
                    case 5:
                        message.remote_attestation_verified = reader.readBool();
                        break;
                    case 6:
                        message.provider_client_token = reader.readBytes();
                        break;
                    case 7:
                        message.protection_scheme = reader.readUint32();
                        break;
                    case 8:
                        message.srm_requirement = reader.readBytes();
                        break;
                    case 9:
                        message.srm_update = reader.readBytes();
                        break;
                    case 10:
                        message.platform_verification_status = reader.readEnum();
                        break;
                    case 11:
                        pb_1.Message.addToRepeatedField(message, 11, reader.readBytes());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): License {
            return License.deserialize(bytes);
        }
    }
    export namespace License {
        export class Policy extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                can_play?: boolean;
                can_persist?: boolean;
                can_renew?: boolean;
                rental_duration_seconds?: number;
                playback_duration_seconds?: number;
                license_duration_seconds?: number;
                renewal_recovery_duration_seconds?: number;
                renewal_server_url?: string;
                renewal_delay_seconds?: number;
                renewal_retry_interval_seconds?: number;
                renew_with_usage?: boolean;
                always_include_client_id?: boolean;
                play_start_grace_period_seconds?: number;
                soft_enforce_playback_duration?: boolean;
                soft_enforce_rental_duration?: boolean;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("can_play" in data && data.can_play != undefined) {
                        this.can_play = data.can_play;
                    }
                    if ("can_persist" in data && data.can_persist != undefined) {
                        this.can_persist = data.can_persist;
                    }
                    if ("can_renew" in data && data.can_renew != undefined) {
                        this.can_renew = data.can_renew;
                    }
                    if ("rental_duration_seconds" in data && data.rental_duration_seconds != undefined) {
                        this.rental_duration_seconds = data.rental_duration_seconds;
                    }
                    if ("playback_duration_seconds" in data && data.playback_duration_seconds != undefined) {
                        this.playback_duration_seconds = data.playback_duration_seconds;
                    }
                    if ("license_duration_seconds" in data && data.license_duration_seconds != undefined) {
                        this.license_duration_seconds = data.license_duration_seconds;
                    }
                    if ("renewal_recovery_duration_seconds" in data && data.renewal_recovery_duration_seconds != undefined) {
                        this.renewal_recovery_duration_seconds = data.renewal_recovery_duration_seconds;
                    }
                    if ("renewal_server_url" in data && data.renewal_server_url != undefined) {
                        this.renewal_server_url = data.renewal_server_url;
                    }
                    if ("renewal_delay_seconds" in data && data.renewal_delay_seconds != undefined) {
                        this.renewal_delay_seconds = data.renewal_delay_seconds;
                    }
                    if ("renewal_retry_interval_seconds" in data && data.renewal_retry_interval_seconds != undefined) {
                        this.renewal_retry_interval_seconds = data.renewal_retry_interval_seconds;
                    }
                    if ("renew_with_usage" in data && data.renew_with_usage != undefined) {
                        this.renew_with_usage = data.renew_with_usage;
                    }
                    if ("always_include_client_id" in data && data.always_include_client_id != undefined) {
                        this.always_include_client_id = data.always_include_client_id;
                    }
                    if ("play_start_grace_period_seconds" in data && data.play_start_grace_period_seconds != undefined) {
                        this.play_start_grace_period_seconds = data.play_start_grace_period_seconds;
                    }
                    if ("soft_enforce_playback_duration" in data && data.soft_enforce_playback_duration != undefined) {
                        this.soft_enforce_playback_duration = data.soft_enforce_playback_duration;
                    }
                    if ("soft_enforce_rental_duration" in data && data.soft_enforce_rental_duration != undefined) {
                        this.soft_enforce_rental_duration = data.soft_enforce_rental_duration;
                    }
                }
            }
            get can_play() {
                return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
            }
            set can_play(value: boolean) {
                pb_1.Message.setField(this, 1, value);
            }
            get has_can_play() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get can_persist() {
                return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
            }
            set can_persist(value: boolean) {
                pb_1.Message.setField(this, 2, value);
            }
            get has_can_persist() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get can_renew() {
                return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
            }
            set can_renew(value: boolean) {
                pb_1.Message.setField(this, 3, value);
            }
            get has_can_renew() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get rental_duration_seconds() {
                return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
            }
            set rental_duration_seconds(value: number) {
                pb_1.Message.setField(this, 4, value);
            }
            get has_rental_duration_seconds() {
                return pb_1.Message.getField(this, 4) != null;
            }
            get playback_duration_seconds() {
                return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
            }
            set playback_duration_seconds(value: number) {
                pb_1.Message.setField(this, 5, value);
            }
            get has_playback_duration_seconds() {
                return pb_1.Message.getField(this, 5) != null;
            }
            get license_duration_seconds() {
                return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
            }
            set license_duration_seconds(value: number) {
                pb_1.Message.setField(this, 6, value);
            }
            get has_license_duration_seconds() {
                return pb_1.Message.getField(this, 6) != null;
            }
            get renewal_recovery_duration_seconds() {
                return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
            }
            set renewal_recovery_duration_seconds(value: number) {
                pb_1.Message.setField(this, 7, value);
            }
            get has_renewal_recovery_duration_seconds() {
                return pb_1.Message.getField(this, 7) != null;
            }
            get renewal_server_url() {
                return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
            }
            set renewal_server_url(value: string) {
                pb_1.Message.setField(this, 8, value);
            }
            get has_renewal_server_url() {
                return pb_1.Message.getField(this, 8) != null;
            }
            get renewal_delay_seconds() {
                return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
            }
            set renewal_delay_seconds(value: number) {
                pb_1.Message.setField(this, 9, value);
            }
            get has_renewal_delay_seconds() {
                return pb_1.Message.getField(this, 9) != null;
            }
            get renewal_retry_interval_seconds() {
                return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
            }
            set renewal_retry_interval_seconds(value: number) {
                pb_1.Message.setField(this, 10, value);
            }
            get has_renewal_retry_interval_seconds() {
                return pb_1.Message.getField(this, 10) != null;
            }
            get renew_with_usage() {
                return pb_1.Message.getFieldWithDefault(this, 11, false) as boolean;
            }
            set renew_with_usage(value: boolean) {
                pb_1.Message.setField(this, 11, value);
            }
            get has_renew_with_usage() {
                return pb_1.Message.getField(this, 11) != null;
            }
            get always_include_client_id() {
                return pb_1.Message.getFieldWithDefault(this, 12, false) as boolean;
            }
            set always_include_client_id(value: boolean) {
                pb_1.Message.setField(this, 12, value);
            }
            get has_always_include_client_id() {
                return pb_1.Message.getField(this, 12) != null;
            }
            get play_start_grace_period_seconds() {
                return pb_1.Message.getFieldWithDefault(this, 13, 0) as number;
            }
            set play_start_grace_period_seconds(value: number) {
                pb_1.Message.setField(this, 13, value);
            }
            get has_play_start_grace_period_seconds() {
                return pb_1.Message.getField(this, 13) != null;
            }
            get soft_enforce_playback_duration() {
                return pb_1.Message.getFieldWithDefault(this, 14, false) as boolean;
            }
            set soft_enforce_playback_duration(value: boolean) {
                pb_1.Message.setField(this, 14, value);
            }
            get has_soft_enforce_playback_duration() {
                return pb_1.Message.getField(this, 14) != null;
            }
            get soft_enforce_rental_duration() {
                return pb_1.Message.getFieldWithDefault(this, 15, true) as boolean;
            }
            set soft_enforce_rental_duration(value: boolean) {
                pb_1.Message.setField(this, 15, value);
            }
            get has_soft_enforce_rental_duration() {
                return pb_1.Message.getField(this, 15) != null;
            }
            static fromObject(data: {
                can_play?: boolean;
                can_persist?: boolean;
                can_renew?: boolean;
                rental_duration_seconds?: number;
                playback_duration_seconds?: number;
                license_duration_seconds?: number;
                renewal_recovery_duration_seconds?: number;
                renewal_server_url?: string;
                renewal_delay_seconds?: number;
                renewal_retry_interval_seconds?: number;
                renew_with_usage?: boolean;
                always_include_client_id?: boolean;
                play_start_grace_period_seconds?: number;
                soft_enforce_playback_duration?: boolean;
                soft_enforce_rental_duration?: boolean;
            }): Policy {
                const message = new Policy({});
                if (data.can_play != null) {
                    message.can_play = data.can_play;
                }
                if (data.can_persist != null) {
                    message.can_persist = data.can_persist;
                }
                if (data.can_renew != null) {
                    message.can_renew = data.can_renew;
                }
                if (data.rental_duration_seconds != null) {
                    message.rental_duration_seconds = data.rental_duration_seconds;
                }
                if (data.playback_duration_seconds != null) {
                    message.playback_duration_seconds = data.playback_duration_seconds;
                }
                if (data.license_duration_seconds != null) {
                    message.license_duration_seconds = data.license_duration_seconds;
                }
                if (data.renewal_recovery_duration_seconds != null) {
                    message.renewal_recovery_duration_seconds = data.renewal_recovery_duration_seconds;
                }
                if (data.renewal_server_url != null) {
                    message.renewal_server_url = data.renewal_server_url;
                }
                if (data.renewal_delay_seconds != null) {
                    message.renewal_delay_seconds = data.renewal_delay_seconds;
                }
                if (data.renewal_retry_interval_seconds != null) {
                    message.renewal_retry_interval_seconds = data.renewal_retry_interval_seconds;
                }
                if (data.renew_with_usage != null) {
                    message.renew_with_usage = data.renew_with_usage;
                }
                if (data.always_include_client_id != null) {
                    message.always_include_client_id = data.always_include_client_id;
                }
                if (data.play_start_grace_period_seconds != null) {
                    message.play_start_grace_period_seconds = data.play_start_grace_period_seconds;
                }
                if (data.soft_enforce_playback_duration != null) {
                    message.soft_enforce_playback_duration = data.soft_enforce_playback_duration;
                }
                if (data.soft_enforce_rental_duration != null) {
                    message.soft_enforce_rental_duration = data.soft_enforce_rental_duration;
                }
                return message;
            }
            toObject() {
                const data: {
                    can_play?: boolean;
                    can_persist?: boolean;
                    can_renew?: boolean;
                    rental_duration_seconds?: number;
                    playback_duration_seconds?: number;
                    license_duration_seconds?: number;
                    renewal_recovery_duration_seconds?: number;
                    renewal_server_url?: string;
                    renewal_delay_seconds?: number;
                    renewal_retry_interval_seconds?: number;
                    renew_with_usage?: boolean;
                    always_include_client_id?: boolean;
                    play_start_grace_period_seconds?: number;
                    soft_enforce_playback_duration?: boolean;
                    soft_enforce_rental_duration?: boolean;
                } = {};
                if (this.can_play != null) {
                    data.can_play = this.can_play;
                }
                if (this.can_persist != null) {
                    data.can_persist = this.can_persist;
                }
                if (this.can_renew != null) {
                    data.can_renew = this.can_renew;
                }
                if (this.rental_duration_seconds != null) {
                    data.rental_duration_seconds = this.rental_duration_seconds;
                }
                if (this.playback_duration_seconds != null) {
                    data.playback_duration_seconds = this.playback_duration_seconds;
                }
                if (this.license_duration_seconds != null) {
                    data.license_duration_seconds = this.license_duration_seconds;
                }
                if (this.renewal_recovery_duration_seconds != null) {
                    data.renewal_recovery_duration_seconds = this.renewal_recovery_duration_seconds;
                }
                if (this.renewal_server_url != null) {
                    data.renewal_server_url = this.renewal_server_url;
                }
                if (this.renewal_delay_seconds != null) {
                    data.renewal_delay_seconds = this.renewal_delay_seconds;
                }
                if (this.renewal_retry_interval_seconds != null) {
                    data.renewal_retry_interval_seconds = this.renewal_retry_interval_seconds;
                }
                if (this.renew_with_usage != null) {
                    data.renew_with_usage = this.renew_with_usage;
                }
                if (this.always_include_client_id != null) {
                    data.always_include_client_id = this.always_include_client_id;
                }
                if (this.play_start_grace_period_seconds != null) {
                    data.play_start_grace_period_seconds = this.play_start_grace_period_seconds;
                }
                if (this.soft_enforce_playback_duration != null) {
                    data.soft_enforce_playback_duration = this.soft_enforce_playback_duration;
                }
                if (this.soft_enforce_rental_duration != null) {
                    data.soft_enforce_rental_duration = this.soft_enforce_rental_duration;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_can_play)
                    writer.writeBool(1, this.can_play);
                if (this.has_can_persist)
                    writer.writeBool(2, this.can_persist);
                if (this.has_can_renew)
                    writer.writeBool(3, this.can_renew);
                if (this.has_rental_duration_seconds)
                    writer.writeInt64(4, this.rental_duration_seconds);
                if (this.has_playback_duration_seconds)
                    writer.writeInt64(5, this.playback_duration_seconds);
                if (this.has_license_duration_seconds)
                    writer.writeInt64(6, this.license_duration_seconds);
                if (this.has_renewal_recovery_duration_seconds)
                    writer.writeInt64(7, this.renewal_recovery_duration_seconds);
                if (this.has_renewal_server_url && this.renewal_server_url.length)
                    writer.writeString(8, this.renewal_server_url);
                if (this.has_renewal_delay_seconds)
                    writer.writeInt64(9, this.renewal_delay_seconds);
                if (this.has_renewal_retry_interval_seconds)
                    writer.writeInt64(10, this.renewal_retry_interval_seconds);
                if (this.has_renew_with_usage)
                    writer.writeBool(11, this.renew_with_usage);
                if (this.has_always_include_client_id)
                    writer.writeBool(12, this.always_include_client_id);
                if (this.has_play_start_grace_period_seconds)
                    writer.writeInt64(13, this.play_start_grace_period_seconds);
                if (this.has_soft_enforce_playback_duration)
                    writer.writeBool(14, this.soft_enforce_playback_duration);
                if (this.has_soft_enforce_rental_duration)
                    writer.writeBool(15, this.soft_enforce_rental_duration);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Policy {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Policy();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.can_play = reader.readBool();
                            break;
                        case 2:
                            message.can_persist = reader.readBool();
                            break;
                        case 3:
                            message.can_renew = reader.readBool();
                            break;
                        case 4:
                            message.rental_duration_seconds = reader.readInt64();
                            break;
                        case 5:
                            message.playback_duration_seconds = reader.readInt64();
                            break;
                        case 6:
                            message.license_duration_seconds = reader.readInt64();
                            break;
                        case 7:
                            message.renewal_recovery_duration_seconds = reader.readInt64();
                            break;
                        case 8:
                            message.renewal_server_url = reader.readString();
                            break;
                        case 9:
                            message.renewal_delay_seconds = reader.readInt64();
                            break;
                        case 10:
                            message.renewal_retry_interval_seconds = reader.readInt64();
                            break;
                        case 11:
                            message.renew_with_usage = reader.readBool();
                            break;
                        case 12:
                            message.always_include_client_id = reader.readBool();
                            break;
                        case 13:
                            message.play_start_grace_period_seconds = reader.readInt64();
                            break;
                        case 14:
                            message.soft_enforce_playback_duration = reader.readBool();
                            break;
                        case 15:
                            message.soft_enforce_rental_duration = reader.readBool();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Policy {
                return Policy.deserialize(bytes);
            }
        }
        export class KeyContainer extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                id?: Uint8Array;
                iv?: Uint8Array;
                key?: Uint8Array;
                type?: License.KeyContainer.KeyType;
                level?: License.KeyContainer.SecurityLevel;
                required_protection?: License.KeyContainer.OutputProtection;
                requested_protection?: License.KeyContainer.OutputProtection;
                key_control?: License.KeyContainer.KeyControl;
                operator_session_key_permissions?: License.KeyContainer.OperatorSessionKeyPermissions;
                video_resolution_constraints: License.KeyContainer.VideoResolutionConstraint[];
                anti_rollback_usage_table?: boolean;
                track_label?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [10], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("id" in data && data.id != undefined) {
                        this.id = data.id;
                    }
                    if ("iv" in data && data.iv != undefined) {
                        this.iv = data.iv;
                    }
                    if ("key" in data && data.key != undefined) {
                        this.key = data.key;
                    }
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("level" in data && data.level != undefined) {
                        this.level = data.level;
                    }
                    if ("required_protection" in data && data.required_protection != undefined) {
                        this.required_protection = data.required_protection;
                    }
                    if ("requested_protection" in data && data.requested_protection != undefined) {
                        this.requested_protection = data.requested_protection;
                    }
                    if ("key_control" in data && data.key_control != undefined) {
                        this.key_control = data.key_control;
                    }
                    if ("operator_session_key_permissions" in data && data.operator_session_key_permissions != undefined) {
                        this.operator_session_key_permissions = data.operator_session_key_permissions;
                    }
                    this.video_resolution_constraints = data.video_resolution_constraints;
                    if ("anti_rollback_usage_table" in data && data.anti_rollback_usage_table != undefined) {
                        this.anti_rollback_usage_table = data.anti_rollback_usage_table;
                    }
                    if ("track_label" in data && data.track_label != undefined) {
                        this.track_label = data.track_label;
                    }
                }
            }
            get id() {
                return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
            }
            set id(value: Uint8Array) {
                pb_1.Message.setField(this, 1, value);
            }
            get has_id() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get iv() {
                return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
            }
            set iv(value: Uint8Array) {
                pb_1.Message.setField(this, 2, value);
            }
            get has_iv() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get key() {
                return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
            }
            set key(value: Uint8Array) {
                pb_1.Message.setField(this, 3, value);
            }
            get has_key() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 4, License.KeyContainer.KeyType.SIGNING) as License.KeyContainer.KeyType;
            }
            set type(value: License.KeyContainer.KeyType) {
                pb_1.Message.setField(this, 4, value);
            }
            get has_type() {
                return pb_1.Message.getField(this, 4) != null;
            }
            get level() {
                return pb_1.Message.getFieldWithDefault(this, 5, License.KeyContainer.SecurityLevel.SW_SECURE_CRYPTO) as License.KeyContainer.SecurityLevel;
            }
            set level(value: License.KeyContainer.SecurityLevel) {
                pb_1.Message.setField(this, 5, value);
            }
            get has_level() {
                return pb_1.Message.getField(this, 5) != null;
            }
            get required_protection() {
                return pb_1.Message.getWrapperField(this, License.KeyContainer.OutputProtection, 6) as License.KeyContainer.OutputProtection;
            }
            set required_protection(value: License.KeyContainer.OutputProtection) {
                pb_1.Message.setWrapperField(this, 6, value);
            }
            get has_required_protection() {
                return pb_1.Message.getField(this, 6) != null;
            }
            get requested_protection() {
                return pb_1.Message.getWrapperField(this, License.KeyContainer.OutputProtection, 7) as License.KeyContainer.OutputProtection;
            }
            set requested_protection(value: License.KeyContainer.OutputProtection) {
                pb_1.Message.setWrapperField(this, 7, value);
            }
            get has_requested_protection() {
                return pb_1.Message.getField(this, 7) != null;
            }
            get key_control() {
                return pb_1.Message.getWrapperField(this, License.KeyContainer.KeyControl, 8) as License.KeyContainer.KeyControl;
            }
            set key_control(value: License.KeyContainer.KeyControl) {
                pb_1.Message.setWrapperField(this, 8, value);
            }
            get has_key_control() {
                return pb_1.Message.getField(this, 8) != null;
            }
            get operator_session_key_permissions() {
                return pb_1.Message.getWrapperField(this, License.KeyContainer.OperatorSessionKeyPermissions, 9) as License.KeyContainer.OperatorSessionKeyPermissions;
            }
            set operator_session_key_permissions(value: License.KeyContainer.OperatorSessionKeyPermissions) {
                pb_1.Message.setWrapperField(this, 9, value);
            }
            get has_operator_session_key_permissions() {
                return pb_1.Message.getField(this, 9) != null;
            }
            get video_resolution_constraints() {
                return pb_1.Message.getRepeatedWrapperField(this, License.KeyContainer.VideoResolutionConstraint, 10) as License.KeyContainer.VideoResolutionConstraint[];
            }
            set video_resolution_constraints(value: License.KeyContainer.VideoResolutionConstraint[]) {
                pb_1.Message.setRepeatedWrapperField(this, 10, value);
            }
            get anti_rollback_usage_table() {
                return pb_1.Message.getFieldWithDefault(this, 11, false) as boolean;
            }
            set anti_rollback_usage_table(value: boolean) {
                pb_1.Message.setField(this, 11, value);
            }
            get has_anti_rollback_usage_table() {
                return pb_1.Message.getField(this, 11) != null;
            }
            get track_label() {
                return pb_1.Message.getFieldWithDefault(this, 12, "") as string;
            }
            set track_label(value: string) {
                pb_1.Message.setField(this, 12, value);
            }
            get has_track_label() {
                return pb_1.Message.getField(this, 12) != null;
            }
            static fromObject(data: {
                id?: Uint8Array;
                iv?: Uint8Array;
                key?: Uint8Array;
                type?: License.KeyContainer.KeyType;
                level?: License.KeyContainer.SecurityLevel;
                required_protection?: ReturnType<typeof License.KeyContainer.OutputProtection.prototype.toObject>;
                requested_protection?: ReturnType<typeof License.KeyContainer.OutputProtection.prototype.toObject>;
                key_control?: ReturnType<typeof License.KeyContainer.KeyControl.prototype.toObject>;
                operator_session_key_permissions?: ReturnType<typeof License.KeyContainer.OperatorSessionKeyPermissions.prototype.toObject>;
                video_resolution_constraints?: ReturnType<typeof License.KeyContainer.VideoResolutionConstraint.prototype.toObject>[];
                anti_rollback_usage_table?: boolean;
                track_label?: string;
            }): KeyContainer {
                const message = new KeyContainer({
                    video_resolution_constraints: data.video_resolution_constraints.map(item => License.KeyContainer.VideoResolutionConstraint.fromObject(item))
                });
                if (data.id != null) {
                    message.id = data.id;
                }
                if (data.iv != null) {
                    message.iv = data.iv;
                }
                if (data.key != null) {
                    message.key = data.key;
                }
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.level != null) {
                    message.level = data.level;
                }
                if (data.required_protection != null) {
                    message.required_protection = License.KeyContainer.OutputProtection.fromObject(data.required_protection);
                }
                if (data.requested_protection != null) {
                    message.requested_protection = License.KeyContainer.OutputProtection.fromObject(data.requested_protection);
                }
                if (data.key_control != null) {
                    message.key_control = License.KeyContainer.KeyControl.fromObject(data.key_control);
                }
                if (data.operator_session_key_permissions != null) {
                    message.operator_session_key_permissions = License.KeyContainer.OperatorSessionKeyPermissions.fromObject(data.operator_session_key_permissions);
                }
                if (data.anti_rollback_usage_table != null) {
                    message.anti_rollback_usage_table = data.anti_rollback_usage_table;
                }
                if (data.track_label != null) {
                    message.track_label = data.track_label;
                }
                return message;
            }
            toObject() {
                const data: {
                    id?: Uint8Array;
                    iv?: Uint8Array;
                    key?: Uint8Array;
                    type?: License.KeyContainer.KeyType;
                    level?: License.KeyContainer.SecurityLevel;
                    required_protection?: ReturnType<typeof License.KeyContainer.OutputProtection.prototype.toObject>;
                    requested_protection?: ReturnType<typeof License.KeyContainer.OutputProtection.prototype.toObject>;
                    key_control?: ReturnType<typeof License.KeyContainer.KeyControl.prototype.toObject>;
                    operator_session_key_permissions?: ReturnType<typeof License.KeyContainer.OperatorSessionKeyPermissions.prototype.toObject>;
                    video_resolution_constraints?: ReturnType<typeof License.KeyContainer.VideoResolutionConstraint.prototype.toObject>[];
                    anti_rollback_usage_table?: boolean;
                    track_label?: string;
                } = {};
                if (this.id != null) {
                    data.id = this.id;
                }
                if (this.iv != null) {
                    data.iv = this.iv;
                }
                if (this.key != null) {
                    data.key = this.key;
                }
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.level != null) {
                    data.level = this.level;
                }
                if (this.required_protection != null) {
                    data.required_protection = this.required_protection.toObject();
                }
                if (this.requested_protection != null) {
                    data.requested_protection = this.requested_protection.toObject();
                }
                if (this.key_control != null) {
                    data.key_control = this.key_control.toObject();
                }
                if (this.operator_session_key_permissions != null) {
                    data.operator_session_key_permissions = this.operator_session_key_permissions.toObject();
                }
                if (this.video_resolution_constraints != null) {
                    data.video_resolution_constraints = this.video_resolution_constraints.map((item: License.KeyContainer.VideoResolutionConstraint) => item.toObject());
                }
                if (this.anti_rollback_usage_table != null) {
                    data.anti_rollback_usage_table = this.anti_rollback_usage_table;
                }
                if (this.track_label != null) {
                    data.track_label = this.track_label;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_id && this.id.length)
                    writer.writeBytes(1, this.id);
                if (this.has_iv && this.iv.length)
                    writer.writeBytes(2, this.iv);
                if (this.has_key && this.key.length)
                    writer.writeBytes(3, this.key);
                if (this.has_type)
                    writer.writeEnum(4, this.type);
                if (this.has_level)
                    writer.writeEnum(5, this.level);
                if (this.has_required_protection)
                    writer.writeMessage(6, this.required_protection, () => this.required_protection.serialize(writer));
                if (this.has_requested_protection)
                    writer.writeMessage(7, this.requested_protection, () => this.requested_protection.serialize(writer));
                if (this.has_key_control)
                    writer.writeMessage(8, this.key_control, () => this.key_control.serialize(writer));
                if (this.has_operator_session_key_permissions)
                    writer.writeMessage(9, this.operator_session_key_permissions, () => this.operator_session_key_permissions.serialize(writer));
                if (this.video_resolution_constraints.length)
                    writer.writeRepeatedMessage(10, this.video_resolution_constraints, (item: License.KeyContainer.VideoResolutionConstraint) => item.serialize(writer));
                if (this.has_anti_rollback_usage_table)
                    writer.writeBool(11, this.anti_rollback_usage_table);
                if (this.has_track_label && this.track_label.length)
                    writer.writeString(12, this.track_label);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): KeyContainer {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new KeyContainer();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.id = reader.readBytes();
                            break;
                        case 2:
                            message.iv = reader.readBytes();
                            break;
                        case 3:
                            message.key = reader.readBytes();
                            break;
                        case 4:
                            message.type = reader.readEnum();
                            break;
                        case 5:
                            message.level = reader.readEnum();
                            break;
                        case 6:
                            reader.readMessage(message.required_protection, () => message.required_protection = License.KeyContainer.OutputProtection.deserialize(reader));
                            break;
                        case 7:
                            reader.readMessage(message.requested_protection, () => message.requested_protection = License.KeyContainer.OutputProtection.deserialize(reader));
                            break;
                        case 8:
                            reader.readMessage(message.key_control, () => message.key_control = License.KeyContainer.KeyControl.deserialize(reader));
                            break;
                        case 9:
                            reader.readMessage(message.operator_session_key_permissions, () => message.operator_session_key_permissions = License.KeyContainer.OperatorSessionKeyPermissions.deserialize(reader));
                            break;
                        case 10:
                            reader.readMessage(message.video_resolution_constraints, () => pb_1.Message.addToRepeatedWrapperField(message, 10, License.KeyContainer.VideoResolutionConstraint.deserialize(reader), License.KeyContainer.VideoResolutionConstraint));
                            break;
                        case 11:
                            message.anti_rollback_usage_table = reader.readBool();
                            break;
                        case 12:
                            message.track_label = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): KeyContainer {
                return KeyContainer.deserialize(bytes);
            }
        }
        export namespace KeyContainer {
            export enum KeyType {
                SIGNING = 1,
                CONTENT = 2,
                KEY_CONTROL = 3,
                OPERATOR_SESSION = 4,
                ENTITLEMENT = 5,
                OEM_CONTENT = 6
            }
            export enum SecurityLevel {
                SW_SECURE_CRYPTO = 1,
                SW_SECURE_DECODE = 2,
                HW_SECURE_CRYPTO = 3,
                HW_SECURE_DECODE = 4,
                HW_SECURE_ALL = 5
            }
            export class KeyControl extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    key_control_block?: Uint8Array;
                    iv?: Uint8Array;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("key_control_block" in data && data.key_control_block != undefined) {
                            this.key_control_block = data.key_control_block;
                        }
                        if ("iv" in data && data.iv != undefined) {
                            this.iv = data.iv;
                        }
                    }
                }
                get key_control_block() {
                    return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
                }
                set key_control_block(value: Uint8Array) {
                    pb_1.Message.setField(this, 1, value);
                }
                get has_key_control_block() {
                    return pb_1.Message.getField(this, 1) != null;
                }
                get iv() {
                    return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
                }
                set iv(value: Uint8Array) {
                    pb_1.Message.setField(this, 2, value);
                }
                get has_iv() {
                    return pb_1.Message.getField(this, 2) != null;
                }
                static fromObject(data: {
                    key_control_block?: Uint8Array;
                    iv?: Uint8Array;
                }): KeyControl {
                    const message = new KeyControl({});
                    if (data.key_control_block != null) {
                        message.key_control_block = data.key_control_block;
                    }
                    if (data.iv != null) {
                        message.iv = data.iv;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        key_control_block?: Uint8Array;
                        iv?: Uint8Array;
                    } = {};
                    if (this.key_control_block != null) {
                        data.key_control_block = this.key_control_block;
                    }
                    if (this.iv != null) {
                        data.iv = this.iv;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.has_key_control_block && this.key_control_block.length)
                        writer.writeBytes(1, this.key_control_block);
                    if (this.has_iv && this.iv.length)
                        writer.writeBytes(2, this.iv);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): KeyControl {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new KeyControl();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.key_control_block = reader.readBytes();
                                break;
                            case 2:
                                message.iv = reader.readBytes();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): KeyControl {
                    return KeyControl.deserialize(bytes);
                }
            }
            export class OutputProtection extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    hdcp?: License.KeyContainer.OutputProtection.HDCP;
                    cgms_flags?: License.KeyContainer.OutputProtection.CGMS;
                    hdcp_srm_rule?: License.KeyContainer.OutputProtection.HdcpSrmRule;
                    disable_analog_output?: boolean;
                    disable_digital_output?: boolean;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("hdcp" in data && data.hdcp != undefined) {
                            this.hdcp = data.hdcp;
                        }
                        if ("cgms_flags" in data && data.cgms_flags != undefined) {
                            this.cgms_flags = data.cgms_flags;
                        }
                        if ("hdcp_srm_rule" in data && data.hdcp_srm_rule != undefined) {
                            this.hdcp_srm_rule = data.hdcp_srm_rule;
                        }
                        if ("disable_analog_output" in data && data.disable_analog_output != undefined) {
                            this.disable_analog_output = data.disable_analog_output;
                        }
                        if ("disable_digital_output" in data && data.disable_digital_output != undefined) {
                            this.disable_digital_output = data.disable_digital_output;
                        }
                    }
                }
                get hdcp() {
                    return pb_1.Message.getFieldWithDefault(this, 1, License.KeyContainer.OutputProtection.HDCP.HDCP_NONE) as License.KeyContainer.OutputProtection.HDCP;
                }
                set hdcp(value: License.KeyContainer.OutputProtection.HDCP) {
                    pb_1.Message.setField(this, 1, value);
                }
                get has_hdcp() {
                    return pb_1.Message.getField(this, 1) != null;
                }
                get cgms_flags() {
                    return pb_1.Message.getFieldWithDefault(this, 2, License.KeyContainer.OutputProtection.CGMS.CGMS_NONE) as License.KeyContainer.OutputProtection.CGMS;
                }
                set cgms_flags(value: License.KeyContainer.OutputProtection.CGMS) {
                    pb_1.Message.setField(this, 2, value);
                }
                get has_cgms_flags() {
                    return pb_1.Message.getField(this, 2) != null;
                }
                get hdcp_srm_rule() {
                    return pb_1.Message.getFieldWithDefault(this, 3, License.KeyContainer.OutputProtection.HdcpSrmRule.HDCP_SRM_RULE_NONE) as License.KeyContainer.OutputProtection.HdcpSrmRule;
                }
                set hdcp_srm_rule(value: License.KeyContainer.OutputProtection.HdcpSrmRule) {
                    pb_1.Message.setField(this, 3, value);
                }
                get has_hdcp_srm_rule() {
                    return pb_1.Message.getField(this, 3) != null;
                }
                get disable_analog_output() {
                    return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
                }
                set disable_analog_output(value: boolean) {
                    pb_1.Message.setField(this, 4, value);
                }
                get has_disable_analog_output() {
                    return pb_1.Message.getField(this, 4) != null;
                }
                get disable_digital_output() {
                    return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
                }
                set disable_digital_output(value: boolean) {
                    pb_1.Message.setField(this, 5, value);
                }
                get has_disable_digital_output() {
                    return pb_1.Message.getField(this, 5) != null;
                }
                static fromObject(data: {
                    hdcp?: License.KeyContainer.OutputProtection.HDCP;
                    cgms_flags?: License.KeyContainer.OutputProtection.CGMS;
                    hdcp_srm_rule?: License.KeyContainer.OutputProtection.HdcpSrmRule;
                    disable_analog_output?: boolean;
                    disable_digital_output?: boolean;
                }): OutputProtection {
                    const message = new OutputProtection({});
                    if (data.hdcp != null) {
                        message.hdcp = data.hdcp;
                    }
                    if (data.cgms_flags != null) {
                        message.cgms_flags = data.cgms_flags;
                    }
                    if (data.hdcp_srm_rule != null) {
                        message.hdcp_srm_rule = data.hdcp_srm_rule;
                    }
                    if (data.disable_analog_output != null) {
                        message.disable_analog_output = data.disable_analog_output;
                    }
                    if (data.disable_digital_output != null) {
                        message.disable_digital_output = data.disable_digital_output;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        hdcp?: License.KeyContainer.OutputProtection.HDCP;
                        cgms_flags?: License.KeyContainer.OutputProtection.CGMS;
                        hdcp_srm_rule?: License.KeyContainer.OutputProtection.HdcpSrmRule;
                        disable_analog_output?: boolean;
                        disable_digital_output?: boolean;
                    } = {};
                    if (this.hdcp != null) {
                        data.hdcp = this.hdcp;
                    }
                    if (this.cgms_flags != null) {
                        data.cgms_flags = this.cgms_flags;
                    }
                    if (this.hdcp_srm_rule != null) {
                        data.hdcp_srm_rule = this.hdcp_srm_rule;
                    }
                    if (this.disable_analog_output != null) {
                        data.disable_analog_output = this.disable_analog_output;
                    }
                    if (this.disable_digital_output != null) {
                        data.disable_digital_output = this.disable_digital_output;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.has_hdcp)
                        writer.writeEnum(1, this.hdcp);
                    if (this.has_cgms_flags)
                        writer.writeEnum(2, this.cgms_flags);
                    if (this.has_hdcp_srm_rule)
                        writer.writeEnum(3, this.hdcp_srm_rule);
                    if (this.has_disable_analog_output)
                        writer.writeBool(4, this.disable_analog_output);
                    if (this.has_disable_digital_output)
                        writer.writeBool(5, this.disable_digital_output);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OutputProtection {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OutputProtection();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.hdcp = reader.readEnum();
                                break;
                            case 2:
                                message.cgms_flags = reader.readEnum();
                                break;
                            case 3:
                                message.hdcp_srm_rule = reader.readEnum();
                                break;
                            case 4:
                                message.disable_analog_output = reader.readBool();
                                break;
                            case 5:
                                message.disable_digital_output = reader.readBool();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): OutputProtection {
                    return OutputProtection.deserialize(bytes);
                }
            }
            export namespace OutputProtection {
                export enum HDCP {
                    HDCP_NONE = 0,
                    HDCP_V1 = 1,
                    HDCP_V2 = 2,
                    HDCP_V2_1 = 3,
                    HDCP_V2_2 = 4,
                    HDCP_V2_3 = 5,
                    HDCP_NO_DIGITAL_OUTPUT = 255
                }
                export enum CGMS {
                    CGMS_NONE = 42,
                    COPY_FREE = 0,
                    COPY_ONCE = 2,
                    COPY_NEVER = 3
                }
                export enum HdcpSrmRule {
                    HDCP_SRM_RULE_NONE = 0,
                    CURRENT_SRM = 1
                }
            }
            export class VideoResolutionConstraint extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    min_resolution_pixels?: number;
                    max_resolution_pixels?: number;
                    required_protection?: License.KeyContainer.OutputProtection;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("min_resolution_pixels" in data && data.min_resolution_pixels != undefined) {
                            this.min_resolution_pixels = data.min_resolution_pixels;
                        }
                        if ("max_resolution_pixels" in data && data.max_resolution_pixels != undefined) {
                            this.max_resolution_pixels = data.max_resolution_pixels;
                        }
                        if ("required_protection" in data && data.required_protection != undefined) {
                            this.required_protection = data.required_protection;
                        }
                    }
                }
                get min_resolution_pixels() {
                    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
                }
                set min_resolution_pixels(value: number) {
                    pb_1.Message.setField(this, 1, value);
                }
                get has_min_resolution_pixels() {
                    return pb_1.Message.getField(this, 1) != null;
                }
                get max_resolution_pixels() {
                    return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
                }
                set max_resolution_pixels(value: number) {
                    pb_1.Message.setField(this, 2, value);
                }
                get has_max_resolution_pixels() {
                    return pb_1.Message.getField(this, 2) != null;
                }
                get required_protection() {
                    return pb_1.Message.getWrapperField(this, License.KeyContainer.OutputProtection, 3) as License.KeyContainer.OutputProtection;
                }
                set required_protection(value: License.KeyContainer.OutputProtection) {
                    pb_1.Message.setWrapperField(this, 3, value);
                }
                get has_required_protection() {
                    return pb_1.Message.getField(this, 3) != null;
                }
                static fromObject(data: {
                    min_resolution_pixels?: number;
                    max_resolution_pixels?: number;
                    required_protection?: ReturnType<typeof License.KeyContainer.OutputProtection.prototype.toObject>;
                }): VideoResolutionConstraint {
                    const message = new VideoResolutionConstraint({});
                    if (data.min_resolution_pixels != null) {
                        message.min_resolution_pixels = data.min_resolution_pixels;
                    }
                    if (data.max_resolution_pixels != null) {
                        message.max_resolution_pixels = data.max_resolution_pixels;
                    }
                    if (data.required_protection != null) {
                        message.required_protection = License.KeyContainer.OutputProtection.fromObject(data.required_protection);
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        min_resolution_pixels?: number;
                        max_resolution_pixels?: number;
                        required_protection?: ReturnType<typeof License.KeyContainer.OutputProtection.prototype.toObject>;
                    } = {};
                    if (this.min_resolution_pixels != null) {
                        data.min_resolution_pixels = this.min_resolution_pixels;
                    }
                    if (this.max_resolution_pixels != null) {
                        data.max_resolution_pixels = this.max_resolution_pixels;
                    }
                    if (this.required_protection != null) {
                        data.required_protection = this.required_protection.toObject();
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.has_min_resolution_pixels)
                        writer.writeUint32(1, this.min_resolution_pixels);
                    if (this.has_max_resolution_pixels)
                        writer.writeUint32(2, this.max_resolution_pixels);
                    if (this.has_required_protection)
                        writer.writeMessage(3, this.required_protection, () => this.required_protection.serialize(writer));
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): VideoResolutionConstraint {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new VideoResolutionConstraint();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.min_resolution_pixels = reader.readUint32();
                                break;
                            case 2:
                                message.max_resolution_pixels = reader.readUint32();
                                break;
                            case 3:
                                reader.readMessage(message.required_protection, () => message.required_protection = License.KeyContainer.OutputProtection.deserialize(reader));
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): VideoResolutionConstraint {
                    return VideoResolutionConstraint.deserialize(bytes);
                }
            }
            export class OperatorSessionKeyPermissions extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    allow_encrypt?: boolean;
                    allow_decrypt?: boolean;
                    allow_sign?: boolean;
                    allow_signature_verify?: boolean;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("allow_encrypt" in data && data.allow_encrypt != undefined) {
                            this.allow_encrypt = data.allow_encrypt;
                        }
                        if ("allow_decrypt" in data && data.allow_decrypt != undefined) {
                            this.allow_decrypt = data.allow_decrypt;
                        }
                        if ("allow_sign" in data && data.allow_sign != undefined) {
                            this.allow_sign = data.allow_sign;
                        }
                        if ("allow_signature_verify" in data && data.allow_signature_verify != undefined) {
                            this.allow_signature_verify = data.allow_signature_verify;
                        }
                    }
                }
                get allow_encrypt() {
                    return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
                }
                set allow_encrypt(value: boolean) {
                    pb_1.Message.setField(this, 1, value);
                }
                get has_allow_encrypt() {
                    return pb_1.Message.getField(this, 1) != null;
                }
                get allow_decrypt() {
                    return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
                }
                set allow_decrypt(value: boolean) {
                    pb_1.Message.setField(this, 2, value);
                }
                get has_allow_decrypt() {
                    return pb_1.Message.getField(this, 2) != null;
                }
                get allow_sign() {
                    return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
                }
                set allow_sign(value: boolean) {
                    pb_1.Message.setField(this, 3, value);
                }
                get has_allow_sign() {
                    return pb_1.Message.getField(this, 3) != null;
                }
                get allow_signature_verify() {
                    return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
                }
                set allow_signature_verify(value: boolean) {
                    pb_1.Message.setField(this, 4, value);
                }
                get has_allow_signature_verify() {
                    return pb_1.Message.getField(this, 4) != null;
                }
                static fromObject(data: {
                    allow_encrypt?: boolean;
                    allow_decrypt?: boolean;
                    allow_sign?: boolean;
                    allow_signature_verify?: boolean;
                }): OperatorSessionKeyPermissions {
                    const message = new OperatorSessionKeyPermissions({});
                    if (data.allow_encrypt != null) {
                        message.allow_encrypt = data.allow_encrypt;
                    }
                    if (data.allow_decrypt != null) {
                        message.allow_decrypt = data.allow_decrypt;
                    }
                    if (data.allow_sign != null) {
                        message.allow_sign = data.allow_sign;
                    }
                    if (data.allow_signature_verify != null) {
                        message.allow_signature_verify = data.allow_signature_verify;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        allow_encrypt?: boolean;
                        allow_decrypt?: boolean;
                        allow_sign?: boolean;
                        allow_signature_verify?: boolean;
                    } = {};
                    if (this.allow_encrypt != null) {
                        data.allow_encrypt = this.allow_encrypt;
                    }
                    if (this.allow_decrypt != null) {
                        data.allow_decrypt = this.allow_decrypt;
                    }
                    if (this.allow_sign != null) {
                        data.allow_sign = this.allow_sign;
                    }
                    if (this.allow_signature_verify != null) {
                        data.allow_signature_verify = this.allow_signature_verify;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.has_allow_encrypt)
                        writer.writeBool(1, this.allow_encrypt);
                    if (this.has_allow_decrypt)
                        writer.writeBool(2, this.allow_decrypt);
                    if (this.has_allow_sign)
                        writer.writeBool(3, this.allow_sign);
                    if (this.has_allow_signature_verify)
                        writer.writeBool(4, this.allow_signature_verify);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OperatorSessionKeyPermissions {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OperatorSessionKeyPermissions();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.allow_encrypt = reader.readBool();
                                break;
                            case 2:
                                message.allow_decrypt = reader.readBool();
                                break;
                            case 3:
                                message.allow_sign = reader.readBool();
                                break;
                            case 4:
                                message.allow_signature_verify = reader.readBool();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): OperatorSessionKeyPermissions {
                    return OperatorSessionKeyPermissions.deserialize(bytes);
                }
            }
        }
    }
    export class LicenseRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            client_id?: ClientIdentification;
            content_id?: LicenseRequest.ContentIdentification;
            type?: LicenseRequest.RequestType;
            request_time?: number;
            key_control_nonce_deprecated?: Uint8Array;
            protocol_version?: ProtocolVersion;
            key_control_nonce?: number;
            encrypted_client_id?: EncryptedClientIdentification;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("client_id" in data && data.client_id != undefined) {
                    this.client_id = data.client_id;
                }
                if ("content_id" in data && data.content_id != undefined) {
                    this.content_id = data.content_id;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("request_time" in data && data.request_time != undefined) {
                    this.request_time = data.request_time;
                }
                if ("key_control_nonce_deprecated" in data && data.key_control_nonce_deprecated != undefined) {
                    this.key_control_nonce_deprecated = data.key_control_nonce_deprecated;
                }
                if ("protocol_version" in data && data.protocol_version != undefined) {
                    this.protocol_version = data.protocol_version;
                }
                if ("key_control_nonce" in data && data.key_control_nonce != undefined) {
                    this.key_control_nonce = data.key_control_nonce;
                }
                if ("encrypted_client_id" in data && data.encrypted_client_id != undefined) {
                    this.encrypted_client_id = data.encrypted_client_id;
                }
            }
        }
        get client_id() {
            return pb_1.Message.getWrapperField(this, ClientIdentification, 1) as ClientIdentification;
        }
        set client_id(value: ClientIdentification) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_client_id() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get content_id() {
            return pb_1.Message.getWrapperField(this, LicenseRequest.ContentIdentification, 2) as LicenseRequest.ContentIdentification;
        }
        set content_id(value: LicenseRequest.ContentIdentification) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_content_id() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 3, LicenseRequest.RequestType.NEW) as LicenseRequest.RequestType;
        }
        set type(value: LicenseRequest.RequestType) {
            pb_1.Message.setField(this, 3, value);
        }
        get has_type() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get request_time() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set request_time(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get has_request_time() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get key_control_nonce_deprecated() {
            return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
        }
        set key_control_nonce_deprecated(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get has_key_control_nonce_deprecated() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get protocol_version() {
            return pb_1.Message.getFieldWithDefault(this, 6, ProtocolVersion.VERSION_2_0) as ProtocolVersion;
        }
        set protocol_version(value: ProtocolVersion) {
            pb_1.Message.setField(this, 6, value);
        }
        get has_protocol_version() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get key_control_nonce() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set key_control_nonce(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get has_key_control_nonce() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get encrypted_client_id() {
            return pb_1.Message.getWrapperField(this, EncryptedClientIdentification, 8) as EncryptedClientIdentification;
        }
        set encrypted_client_id(value: EncryptedClientIdentification) {
            pb_1.Message.setWrapperField(this, 8, value);
        }
        get has_encrypted_client_id() {
            return pb_1.Message.getField(this, 8) != null;
        }
        static fromObject(data: {
            client_id?: ReturnType<typeof ClientIdentification.prototype.toObject>;
            content_id?: ReturnType<typeof LicenseRequest.ContentIdentification.prototype.toObject>;
            type?: LicenseRequest.RequestType;
            request_time?: number;
            key_control_nonce_deprecated?: Uint8Array;
            protocol_version?: ProtocolVersion;
            key_control_nonce?: number;
            encrypted_client_id?: ReturnType<typeof EncryptedClientIdentification.prototype.toObject>;
        }): LicenseRequest {
            const message = new LicenseRequest({});
            if (data.client_id != null) {
                message.client_id = ClientIdentification.fromObject(data.client_id);
            }
            if (data.content_id != null) {
                message.content_id = LicenseRequest.ContentIdentification.fromObject(data.content_id);
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.request_time != null) {
                message.request_time = data.request_time;
            }
            if (data.key_control_nonce_deprecated != null) {
                message.key_control_nonce_deprecated = data.key_control_nonce_deprecated;
            }
            if (data.protocol_version != null) {
                message.protocol_version = data.protocol_version;
            }
            if (data.key_control_nonce != null) {
                message.key_control_nonce = data.key_control_nonce;
            }
            if (data.encrypted_client_id != null) {
                message.encrypted_client_id = EncryptedClientIdentification.fromObject(data.encrypted_client_id);
            }
            return message;
        }
        toObject() {
            const data: {
                client_id?: ReturnType<typeof ClientIdentification.prototype.toObject>;
                content_id?: ReturnType<typeof LicenseRequest.ContentIdentification.prototype.toObject>;
                type?: LicenseRequest.RequestType;
                request_time?: number;
                key_control_nonce_deprecated?: Uint8Array;
                protocol_version?: ProtocolVersion;
                key_control_nonce?: number;
                encrypted_client_id?: ReturnType<typeof EncryptedClientIdentification.prototype.toObject>;
            } = {};
            if (this.client_id != null) {
                data.client_id = this.client_id.toObject();
            }
            if (this.content_id != null) {
                data.content_id = this.content_id.toObject();
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.request_time != null) {
                data.request_time = this.request_time;
            }
            if (this.key_control_nonce_deprecated != null) {
                data.key_control_nonce_deprecated = this.key_control_nonce_deprecated;
            }
            if (this.protocol_version != null) {
                data.protocol_version = this.protocol_version;
            }
            if (this.key_control_nonce != null) {
                data.key_control_nonce = this.key_control_nonce;
            }
            if (this.encrypted_client_id != null) {
                data.encrypted_client_id = this.encrypted_client_id.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_client_id)
                writer.writeMessage(1, this.client_id, () => this.client_id.serialize(writer));
            if (this.has_content_id)
                writer.writeMessage(2, this.content_id, () => this.content_id.serialize(writer));
            if (this.has_type)
                writer.writeEnum(3, this.type);
            if (this.has_request_time)
                writer.writeInt64(4, this.request_time);
            if (this.has_key_control_nonce_deprecated && this.key_control_nonce_deprecated.length)
                writer.writeBytes(5, this.key_control_nonce_deprecated);
            if (this.has_protocol_version)
                writer.writeEnum(6, this.protocol_version);
            if (this.has_key_control_nonce)
                writer.writeUint32(7, this.key_control_nonce);
            if (this.has_encrypted_client_id)
                writer.writeMessage(8, this.encrypted_client_id, () => this.encrypted_client_id.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LicenseRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LicenseRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.client_id, () => message.client_id = ClientIdentification.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.content_id, () => message.content_id = LicenseRequest.ContentIdentification.deserialize(reader));
                        break;
                    case 3:
                        message.type = reader.readEnum();
                        break;
                    case 4:
                        message.request_time = reader.readInt64();
                        break;
                    case 5:
                        message.key_control_nonce_deprecated = reader.readBytes();
                        break;
                    case 6:
                        message.protocol_version = reader.readEnum();
                        break;
                    case 7:
                        message.key_control_nonce = reader.readUint32();
                        break;
                    case 8:
                        reader.readMessage(message.encrypted_client_id, () => message.encrypted_client_id = EncryptedClientIdentification.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LicenseRequest {
            return LicenseRequest.deserialize(bytes);
        }
    }
    export namespace LicenseRequest {
        export enum RequestType {
            NEW = 1,
            RENEWAL = 2,
            RELEASE = 3
        }
        export class ContentIdentification extends pb_1.Message {
            #one_of_decls: number[][] = [[1, 2, 3, 4]];
            constructor(data?: any[] | ({} & (({
                widevine_pssh_data?: LicenseRequest.ContentIdentification.WidevinePsshData;
                webm_key_id?: never;
                existing_license?: never;
                init_data?: never;
            } | {
                widevine_pssh_data?: never;
                webm_key_id?: LicenseRequest.ContentIdentification.WebmKeyId;
                existing_license?: never;
                init_data?: never;
            } | {
                widevine_pssh_data?: never;
                webm_key_id?: never;
                existing_license?: LicenseRequest.ContentIdentification.ExistingLicense;
                init_data?: never;
            } | {
                widevine_pssh_data?: never;
                webm_key_id?: never;
                existing_license?: never;
                init_data?: LicenseRequest.ContentIdentification.InitData;
            })))) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("widevine_pssh_data" in data && data.widevine_pssh_data != undefined) {
                        this.widevine_pssh_data = data.widevine_pssh_data;
                    }
                    if ("webm_key_id" in data && data.webm_key_id != undefined) {
                        this.webm_key_id = data.webm_key_id;
                    }
                    if ("existing_license" in data && data.existing_license != undefined) {
                        this.existing_license = data.existing_license;
                    }
                    if ("init_data" in data && data.init_data != undefined) {
                        this.init_data = data.init_data;
                    }
                }
            }
            get widevine_pssh_data() {
                return pb_1.Message.getWrapperField(this, LicenseRequest.ContentIdentification.WidevinePsshData, 1) as LicenseRequest.ContentIdentification.WidevinePsshData;
            }
            set widevine_pssh_data(value: LicenseRequest.ContentIdentification.WidevinePsshData) {
                pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
            }
            get has_widevine_pssh_data() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get webm_key_id() {
                return pb_1.Message.getWrapperField(this, LicenseRequest.ContentIdentification.WebmKeyId, 2) as LicenseRequest.ContentIdentification.WebmKeyId;
            }
            set webm_key_id(value: LicenseRequest.ContentIdentification.WebmKeyId) {
                pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
            }
            get has_webm_key_id() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get existing_license() {
                return pb_1.Message.getWrapperField(this, LicenseRequest.ContentIdentification.ExistingLicense, 3) as LicenseRequest.ContentIdentification.ExistingLicense;
            }
            set existing_license(value: LicenseRequest.ContentIdentification.ExistingLicense) {
                pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
            }
            get has_existing_license() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get init_data() {
                return pb_1.Message.getWrapperField(this, LicenseRequest.ContentIdentification.InitData, 4) as LicenseRequest.ContentIdentification.InitData;
            }
            set init_data(value: LicenseRequest.ContentIdentification.InitData) {
                pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
            }
            get has_init_data() {
                return pb_1.Message.getField(this, 4) != null;
            }
            get content_id_variant() {
                const cases: {
                    [index: number]: "none" | "widevine_pssh_data" | "webm_key_id" | "existing_license" | "init_data";
                } = {
                    0: "none",
                    1: "widevine_pssh_data",
                    2: "webm_key_id",
                    3: "existing_license",
                    4: "init_data"
                };
                return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4])];
            }
            static fromObject(data: {
                widevine_pssh_data?: ReturnType<typeof LicenseRequest.ContentIdentification.WidevinePsshData.prototype.toObject>;
                webm_key_id?: ReturnType<typeof LicenseRequest.ContentIdentification.WebmKeyId.prototype.toObject>;
                existing_license?: ReturnType<typeof LicenseRequest.ContentIdentification.ExistingLicense.prototype.toObject>;
                init_data?: ReturnType<typeof LicenseRequest.ContentIdentification.InitData.prototype.toObject>;
            }): ContentIdentification {
                const message = new ContentIdentification({});
                if (data.widevine_pssh_data != null) {
                    message.widevine_pssh_data = LicenseRequest.ContentIdentification.WidevinePsshData.fromObject(data.widevine_pssh_data);
                }
                if (data.webm_key_id != null) {
                    message.webm_key_id = LicenseRequest.ContentIdentification.WebmKeyId.fromObject(data.webm_key_id);
                }
                if (data.existing_license != null) {
                    message.existing_license = LicenseRequest.ContentIdentification.ExistingLicense.fromObject(data.existing_license);
                }
                if (data.init_data != null) {
                    message.init_data = LicenseRequest.ContentIdentification.InitData.fromObject(data.init_data);
                }
                return message;
            }
            toObject() {
                const data: {
                    widevine_pssh_data?: ReturnType<typeof LicenseRequest.ContentIdentification.WidevinePsshData.prototype.toObject>;
                    webm_key_id?: ReturnType<typeof LicenseRequest.ContentIdentification.WebmKeyId.prototype.toObject>;
                    existing_license?: ReturnType<typeof LicenseRequest.ContentIdentification.ExistingLicense.prototype.toObject>;
                    init_data?: ReturnType<typeof LicenseRequest.ContentIdentification.InitData.prototype.toObject>;
                } = {};
                if (this.widevine_pssh_data != null) {
                    data.widevine_pssh_data = this.widevine_pssh_data.toObject();
                }
                if (this.webm_key_id != null) {
                    data.webm_key_id = this.webm_key_id.toObject();
                }
                if (this.existing_license != null) {
                    data.existing_license = this.existing_license.toObject();
                }
                if (this.init_data != null) {
                    data.init_data = this.init_data.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_widevine_pssh_data)
                    writer.writeMessage(1, this.widevine_pssh_data, () => this.widevine_pssh_data.serialize(writer));
                if (this.has_webm_key_id)
                    writer.writeMessage(2, this.webm_key_id, () => this.webm_key_id.serialize(writer));
                if (this.has_existing_license)
                    writer.writeMessage(3, this.existing_license, () => this.existing_license.serialize(writer));
                if (this.has_init_data)
                    writer.writeMessage(4, this.init_data, () => this.init_data.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ContentIdentification {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ContentIdentification();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.widevine_pssh_data, () => message.widevine_pssh_data = LicenseRequest.ContentIdentification.WidevinePsshData.deserialize(reader));
                            break;
                        case 2:
                            reader.readMessage(message.webm_key_id, () => message.webm_key_id = LicenseRequest.ContentIdentification.WebmKeyId.deserialize(reader));
                            break;
                        case 3:
                            reader.readMessage(message.existing_license, () => message.existing_license = LicenseRequest.ContentIdentification.ExistingLicense.deserialize(reader));
                            break;
                        case 4:
                            reader.readMessage(message.init_data, () => message.init_data = LicenseRequest.ContentIdentification.InitData.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): ContentIdentification {
                return ContentIdentification.deserialize(bytes);
            }
        }
        export namespace ContentIdentification {
            export class WidevinePsshData extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    pssh_data: Uint8Array[];
                    license_type?: LicenseType;
                    request_id?: Uint8Array;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        this.pssh_data = data.pssh_data;
                        if ("license_type" in data && data.license_type != undefined) {
                            this.license_type = data.license_type;
                        }
                        if ("request_id" in data && data.request_id != undefined) {
                            this.request_id = data.request_id;
                        }
                    }
                }
                get pssh_data() {
                    return pb_1.Message.getFieldWithDefault(this, 1, []) as Uint8Array[];
                }
                set pssh_data(value: Uint8Array[]) {
                    pb_1.Message.setField(this, 1, value);
                }
                get license_type() {
                    return pb_1.Message.getFieldWithDefault(this, 2, LicenseType.STREAMING) as LicenseType;
                }
                set license_type(value: LicenseType) {
                    pb_1.Message.setField(this, 2, value);
                }
                get has_license_type() {
                    return pb_1.Message.getField(this, 2) != null;
                }
                get request_id() {
                    return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
                }
                set request_id(value: Uint8Array) {
                    pb_1.Message.setField(this, 3, value);
                }
                get has_request_id() {
                    return pb_1.Message.getField(this, 3) != null;
                }
                static fromObject(data: {
                    pssh_data: Uint8Array[];
                    license_type?: LicenseType;
                    request_id?: Uint8Array;
                }): WidevinePsshData {
                    const message = new WidevinePsshData({
                        pssh_data: data.pssh_data
                    });
                    if (data.license_type != null) {
                        message.license_type = data.license_type;
                    }
                    if (data.request_id != null) {
                        message.request_id = data.request_id;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        pssh_data: Uint8Array[];
                        license_type?: LicenseType;
                        request_id?: Uint8Array;
                    } = {
                        pssh_data: this.pssh_data
                    };
                    if (this.license_type != null) {
                        data.license_type = this.license_type;
                    }
                    if (this.request_id != null) {
                        data.request_id = this.request_id;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.pssh_data.length)
                        writer.writeRepeatedBytes(1, this.pssh_data);
                    if (this.has_license_type)
                        writer.writeEnum(2, this.license_type);
                    if (this.has_request_id && this.request_id.length)
                        writer.writeBytes(3, this.request_id);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WidevinePsshData {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WidevinePsshData();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                pb_1.Message.addToRepeatedField(message, 1, reader.readBytes());
                                break;
                            case 2:
                                message.license_type = reader.readEnum();
                                break;
                            case 3:
                                message.request_id = reader.readBytes();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): WidevinePsshData {
                    return WidevinePsshData.deserialize(bytes);
                }
            }
            export class WebmKeyId extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    header?: Uint8Array;
                    license_type?: LicenseType;
                    request_id?: Uint8Array;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("header" in data && data.header != undefined) {
                            this.header = data.header;
                        }
                        if ("license_type" in data && data.license_type != undefined) {
                            this.license_type = data.license_type;
                        }
                        if ("request_id" in data && data.request_id != undefined) {
                            this.request_id = data.request_id;
                        }
                    }
                }
                get header() {
                    return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
                }
                set header(value: Uint8Array) {
                    pb_1.Message.setField(this, 1, value);
                }
                get has_header() {
                    return pb_1.Message.getField(this, 1) != null;
                }
                get license_type() {
                    return pb_1.Message.getFieldWithDefault(this, 2, LicenseType.STREAMING) as LicenseType;
                }
                set license_type(value: LicenseType) {
                    pb_1.Message.setField(this, 2, value);
                }
                get has_license_type() {
                    return pb_1.Message.getField(this, 2) != null;
                }
                get request_id() {
                    return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
                }
                set request_id(value: Uint8Array) {
                    pb_1.Message.setField(this, 3, value);
                }
                get has_request_id() {
                    return pb_1.Message.getField(this, 3) != null;
                }
                static fromObject(data: {
                    header?: Uint8Array;
                    license_type?: LicenseType;
                    request_id?: Uint8Array;
                }): WebmKeyId {
                    const message = new WebmKeyId({});
                    if (data.header != null) {
                        message.header = data.header;
                    }
                    if (data.license_type != null) {
                        message.license_type = data.license_type;
                    }
                    if (data.request_id != null) {
                        message.request_id = data.request_id;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        header?: Uint8Array;
                        license_type?: LicenseType;
                        request_id?: Uint8Array;
                    } = {};
                    if (this.header != null) {
                        data.header = this.header;
                    }
                    if (this.license_type != null) {
                        data.license_type = this.license_type;
                    }
                    if (this.request_id != null) {
                        data.request_id = this.request_id;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.has_header && this.header.length)
                        writer.writeBytes(1, this.header);
                    if (this.has_license_type)
                        writer.writeEnum(2, this.license_type);
                    if (this.has_request_id && this.request_id.length)
                        writer.writeBytes(3, this.request_id);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WebmKeyId {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WebmKeyId();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.header = reader.readBytes();
                                break;
                            case 2:
                                message.license_type = reader.readEnum();
                                break;
                            case 3:
                                message.request_id = reader.readBytes();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): WebmKeyId {
                    return WebmKeyId.deserialize(bytes);
                }
            }
            export class ExistingLicense extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    license_id?: LicenseIdentification;
                    seconds_since_started?: number;
                    seconds_since_last_played?: number;
                    session_usage_table_entry?: Uint8Array;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("license_id" in data && data.license_id != undefined) {
                            this.license_id = data.license_id;
                        }
                        if ("seconds_since_started" in data && data.seconds_since_started != undefined) {
                            this.seconds_since_started = data.seconds_since_started;
                        }
                        if ("seconds_since_last_played" in data && data.seconds_since_last_played != undefined) {
                            this.seconds_since_last_played = data.seconds_since_last_played;
                        }
                        if ("session_usage_table_entry" in data && data.session_usage_table_entry != undefined) {
                            this.session_usage_table_entry = data.session_usage_table_entry;
                        }
                    }
                }
                get license_id() {
                    return pb_1.Message.getWrapperField(this, LicenseIdentification, 1) as LicenseIdentification;
                }
                set license_id(value: LicenseIdentification) {
                    pb_1.Message.setWrapperField(this, 1, value);
                }
                get has_license_id() {
                    return pb_1.Message.getField(this, 1) != null;
                }
                get seconds_since_started() {
                    return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
                }
                set seconds_since_started(value: number) {
                    pb_1.Message.setField(this, 2, value);
                }
                get has_seconds_since_started() {
                    return pb_1.Message.getField(this, 2) != null;
                }
                get seconds_since_last_played() {
                    return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
                }
                set seconds_since_last_played(value: number) {
                    pb_1.Message.setField(this, 3, value);
                }
                get has_seconds_since_last_played() {
                    return pb_1.Message.getField(this, 3) != null;
                }
                get session_usage_table_entry() {
                    return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array(0)) as Uint8Array;
                }
                set session_usage_table_entry(value: Uint8Array) {
                    pb_1.Message.setField(this, 4, value);
                }
                get has_session_usage_table_entry() {
                    return pb_1.Message.getField(this, 4) != null;
                }
                static fromObject(data: {
                    license_id?: ReturnType<typeof LicenseIdentification.prototype.toObject>;
                    seconds_since_started?: number;
                    seconds_since_last_played?: number;
                    session_usage_table_entry?: Uint8Array;
                }): ExistingLicense {
                    const message = new ExistingLicense({});
                    if (data.license_id != null) {
                        message.license_id = LicenseIdentification.fromObject(data.license_id);
                    }
                    if (data.seconds_since_started != null) {
                        message.seconds_since_started = data.seconds_since_started;
                    }
                    if (data.seconds_since_last_played != null) {
                        message.seconds_since_last_played = data.seconds_since_last_played;
                    }
                    if (data.session_usage_table_entry != null) {
                        message.session_usage_table_entry = data.session_usage_table_entry;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        license_id?: ReturnType<typeof LicenseIdentification.prototype.toObject>;
                        seconds_since_started?: number;
                        seconds_since_last_played?: number;
                        session_usage_table_entry?: Uint8Array;
                    } = {};
                    if (this.license_id != null) {
                        data.license_id = this.license_id.toObject();
                    }
                    if (this.seconds_since_started != null) {
                        data.seconds_since_started = this.seconds_since_started;
                    }
                    if (this.seconds_since_last_played != null) {
                        data.seconds_since_last_played = this.seconds_since_last_played;
                    }
                    if (this.session_usage_table_entry != null) {
                        data.session_usage_table_entry = this.session_usage_table_entry;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.has_license_id)
                        writer.writeMessage(1, this.license_id, () => this.license_id.serialize(writer));
                    if (this.has_seconds_since_started)
                        writer.writeInt64(2, this.seconds_since_started);
                    if (this.has_seconds_since_last_played)
                        writer.writeInt64(3, this.seconds_since_last_played);
                    if (this.has_session_usage_table_entry && this.session_usage_table_entry.length)
                        writer.writeBytes(4, this.session_usage_table_entry);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExistingLicense {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ExistingLicense();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                reader.readMessage(message.license_id, () => message.license_id = LicenseIdentification.deserialize(reader));
                                break;
                            case 2:
                                message.seconds_since_started = reader.readInt64();
                                break;
                            case 3:
                                message.seconds_since_last_played = reader.readInt64();
                                break;
                            case 4:
                                message.session_usage_table_entry = reader.readBytes();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): ExistingLicense {
                    return ExistingLicense.deserialize(bytes);
                }
            }
            export class InitData extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    init_data_type?: LicenseRequest.ContentIdentification.InitData.InitDataType;
                    init_data?: Uint8Array;
                    license_type?: LicenseType;
                    request_id?: Uint8Array;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("init_data_type" in data && data.init_data_type != undefined) {
                            this.init_data_type = data.init_data_type;
                        }
                        if ("init_data" in data && data.init_data != undefined) {
                            this.init_data = data.init_data;
                        }
                        if ("license_type" in data && data.license_type != undefined) {
                            this.license_type = data.license_type;
                        }
                        if ("request_id" in data && data.request_id != undefined) {
                            this.request_id = data.request_id;
                        }
                    }
                }
                get init_data_type() {
                    return pb_1.Message.getFieldWithDefault(this, 1, LicenseRequest.ContentIdentification.InitData.InitDataType.CENC) as LicenseRequest.ContentIdentification.InitData.InitDataType;
                }
                set init_data_type(value: LicenseRequest.ContentIdentification.InitData.InitDataType) {
                    pb_1.Message.setField(this, 1, value);
                }
                get has_init_data_type() {
                    return pb_1.Message.getField(this, 1) != null;
                }
                get init_data() {
                    return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
                }
                set init_data(value: Uint8Array) {
                    pb_1.Message.setField(this, 2, value);
                }
                get has_init_data() {
                    return pb_1.Message.getField(this, 2) != null;
                }
                get license_type() {
                    return pb_1.Message.getFieldWithDefault(this, 3, LicenseType.STREAMING) as LicenseType;
                }
                set license_type(value: LicenseType) {
                    pb_1.Message.setField(this, 3, value);
                }
                get has_license_type() {
                    return pb_1.Message.getField(this, 3) != null;
                }
                get request_id() {
                    return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array(0)) as Uint8Array;
                }
                set request_id(value: Uint8Array) {
                    pb_1.Message.setField(this, 4, value);
                }
                get has_request_id() {
                    return pb_1.Message.getField(this, 4) != null;
                }
                static fromObject(data: {
                    init_data_type?: LicenseRequest.ContentIdentification.InitData.InitDataType;
                    init_data?: Uint8Array;
                    license_type?: LicenseType;
                    request_id?: Uint8Array;
                }): InitData {
                    const message = new InitData({});
                    if (data.init_data_type != null) {
                        message.init_data_type = data.init_data_type;
                    }
                    if (data.init_data != null) {
                        message.init_data = data.init_data;
                    }
                    if (data.license_type != null) {
                        message.license_type = data.license_type;
                    }
                    if (data.request_id != null) {
                        message.request_id = data.request_id;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        init_data_type?: LicenseRequest.ContentIdentification.InitData.InitDataType;
                        init_data?: Uint8Array;
                        license_type?: LicenseType;
                        request_id?: Uint8Array;
                    } = {};
                    if (this.init_data_type != null) {
                        data.init_data_type = this.init_data_type;
                    }
                    if (this.init_data != null) {
                        data.init_data = this.init_data;
                    }
                    if (this.license_type != null) {
                        data.license_type = this.license_type;
                    }
                    if (this.request_id != null) {
                        data.request_id = this.request_id;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.has_init_data_type)
                        writer.writeEnum(1, this.init_data_type);
                    if (this.has_init_data && this.init_data.length)
                        writer.writeBytes(2, this.init_data);
                    if (this.has_license_type)
                        writer.writeEnum(3, this.license_type);
                    if (this.has_request_id && this.request_id.length)
                        writer.writeBytes(4, this.request_id);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): InitData {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new InitData();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.init_data_type = reader.readEnum();
                                break;
                            case 2:
                                message.init_data = reader.readBytes();
                                break;
                            case 3:
                                message.license_type = reader.readEnum();
                                break;
                            case 4:
                                message.request_id = reader.readBytes();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): InitData {
                    return InitData.deserialize(bytes);
                }
            }
            export namespace InitData {
                export enum InitDataType {
                    CENC = 1,
                    WEBM = 2
                }
            }
        }
    }
    export class MetricData extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            stage_name?: string;
            metric_data: MetricData.TypeValue[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("stage_name" in data && data.stage_name != undefined) {
                    this.stage_name = data.stage_name;
                }
                this.metric_data = data.metric_data;
            }
        }
        get stage_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set stage_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_stage_name() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get metric_data() {
            return pb_1.Message.getRepeatedWrapperField(this, MetricData.TypeValue, 2) as MetricData.TypeValue[];
        }
        set metric_data(value: MetricData.TypeValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            stage_name?: string;
            metric_data?: ReturnType<typeof MetricData.TypeValue.prototype.toObject>[];
        }): MetricData {
            const message = new MetricData({
                metric_data: data.metric_data.map(item => MetricData.TypeValue.fromObject(item))
            });
            if (data.stage_name != null) {
                message.stage_name = data.stage_name;
            }
            return message;
        }
        toObject() {
            const data: {
                stage_name?: string;
                metric_data?: ReturnType<typeof MetricData.TypeValue.prototype.toObject>[];
            } = {};
            if (this.stage_name != null) {
                data.stage_name = this.stage_name;
            }
            if (this.metric_data != null) {
                data.metric_data = this.metric_data.map((item: MetricData.TypeValue) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_stage_name && this.stage_name.length)
                writer.writeString(1, this.stage_name);
            if (this.metric_data.length)
                writer.writeRepeatedMessage(2, this.metric_data, (item: MetricData.TypeValue) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MetricData {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MetricData();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.stage_name = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.metric_data, () => pb_1.Message.addToRepeatedWrapperField(message, 2, MetricData.TypeValue.deserialize(reader), MetricData.TypeValue));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MetricData {
            return MetricData.deserialize(bytes);
        }
    }
    export namespace MetricData {
        export enum MetricType {
            LATENCY = 1,
            TIMESTAMP = 2
        }
        export class TypeValue extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                type?: MetricData.MetricType;
                value?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("value" in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 1, MetricData.MetricType.LATENCY) as MetricData.MetricType;
            }
            set type(value: MetricData.MetricType) {
                pb_1.Message.setField(this, 1, value);
            }
            get has_type() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get value() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set value(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get has_value() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                type?: MetricData.MetricType;
                value?: number;
            }): TypeValue {
                const message = new TypeValue({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data: {
                    type?: MetricData.MetricType;
                    value?: number;
                } = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_type)
                    writer.writeEnum(1, this.type);
                if (this.has_value)
                    writer.writeInt64(2, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TypeValue {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TypeValue();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readEnum();
                            break;
                        case 2:
                            message.value = reader.readInt64();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): TypeValue {
                return TypeValue.deserialize(bytes);
            }
        }
    }
    export class VersionInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            license_sdk_version?: string;
            license_service_version?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("license_sdk_version" in data && data.license_sdk_version != undefined) {
                    this.license_sdk_version = data.license_sdk_version;
                }
                if ("license_service_version" in data && data.license_service_version != undefined) {
                    this.license_service_version = data.license_service_version;
                }
            }
        }
        get license_sdk_version() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set license_sdk_version(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_license_sdk_version() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get license_service_version() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set license_service_version(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get has_license_service_version() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            license_sdk_version?: string;
            license_service_version?: string;
        }): VersionInfo {
            const message = new VersionInfo({});
            if (data.license_sdk_version != null) {
                message.license_sdk_version = data.license_sdk_version;
            }
            if (data.license_service_version != null) {
                message.license_service_version = data.license_service_version;
            }
            return message;
        }
        toObject() {
            const data: {
                license_sdk_version?: string;
                license_service_version?: string;
            } = {};
            if (this.license_sdk_version != null) {
                data.license_sdk_version = this.license_sdk_version;
            }
            if (this.license_service_version != null) {
                data.license_service_version = this.license_service_version;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_license_sdk_version && this.license_sdk_version.length)
                writer.writeString(1, this.license_sdk_version);
            if (this.has_license_service_version && this.license_service_version.length)
                writer.writeString(2, this.license_service_version);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): VersionInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new VersionInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.license_sdk_version = reader.readString();
                        break;
                    case 2:
                        message.license_service_version = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): VersionInfo {
            return VersionInfo.deserialize(bytes);
        }
    }
    export class SignedMessage extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: SignedMessage.MessageType;
            msg?: Uint8Array;
            signature?: Uint8Array;
            session_key?: Uint8Array;
            remote_attestation?: Uint8Array;
            metric_data: MetricData[];
            service_version_info?: VersionInfo;
            session_key_type?: SignedMessage.SessionKeyType;
            oemcrypto_core_message?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [6], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("msg" in data && data.msg != undefined) {
                    this.msg = data.msg;
                }
                if ("signature" in data && data.signature != undefined) {
                    this.signature = data.signature;
                }
                if ("session_key" in data && data.session_key != undefined) {
                    this.session_key = data.session_key;
                }
                if ("remote_attestation" in data && data.remote_attestation != undefined) {
                    this.remote_attestation = data.remote_attestation;
                }
                this.metric_data = data.metric_data;
                if ("service_version_info" in data && data.service_version_info != undefined) {
                    this.service_version_info = data.service_version_info;
                }
                if ("session_key_type" in data && data.session_key_type != undefined) {
                    this.session_key_type = data.session_key_type;
                }
                if ("oemcrypto_core_message" in data && data.oemcrypto_core_message != undefined) {
                    this.oemcrypto_core_message = data.oemcrypto_core_message;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, SignedMessage.MessageType.LICENSE_REQUEST) as SignedMessage.MessageType;
        }
        set type(value: SignedMessage.MessageType) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_type() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get msg() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set msg(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get has_msg() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get signature() {
            return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
        }
        set signature(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        get has_signature() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get session_key() {
            return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array(0)) as Uint8Array;
        }
        set session_key(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get has_session_key() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get remote_attestation() {
            return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
        }
        set remote_attestation(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get has_remote_attestation() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get metric_data() {
            return pb_1.Message.getRepeatedWrapperField(this, MetricData, 6) as MetricData[];
        }
        set metric_data(value: MetricData[]) {
            pb_1.Message.setRepeatedWrapperField(this, 6, value);
        }
        get service_version_info() {
            return pb_1.Message.getWrapperField(this, VersionInfo, 7) as VersionInfo;
        }
        set service_version_info(value: VersionInfo) {
            pb_1.Message.setWrapperField(this, 7, value);
        }
        get has_service_version_info() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get session_key_type() {
            return pb_1.Message.getFieldWithDefault(this, 8, SignedMessage.SessionKeyType.WRAPPED_AES_KEY) as SignedMessage.SessionKeyType;
        }
        set session_key_type(value: SignedMessage.SessionKeyType) {
            pb_1.Message.setField(this, 8, value);
        }
        get has_session_key_type() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get oemcrypto_core_message() {
            return pb_1.Message.getFieldWithDefault(this, 9, new Uint8Array(0)) as Uint8Array;
        }
        set oemcrypto_core_message(value: Uint8Array) {
            pb_1.Message.setField(this, 9, value);
        }
        get has_oemcrypto_core_message() {
            return pb_1.Message.getField(this, 9) != null;
        }
        static fromObject(data: {
            type?: SignedMessage.MessageType;
            msg?: Uint8Array;
            signature?: Uint8Array;
            session_key?: Uint8Array;
            remote_attestation?: Uint8Array;
            metric_data?: ReturnType<typeof MetricData.prototype.toObject>[];
            service_version_info?: ReturnType<typeof VersionInfo.prototype.toObject>;
            session_key_type?: SignedMessage.SessionKeyType;
            oemcrypto_core_message?: Uint8Array;
        }): SignedMessage {
            const message = new SignedMessage({
                metric_data: data.metric_data.map(item => MetricData.fromObject(item))
            });
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.msg != null) {
                message.msg = data.msg;
            }
            if (data.signature != null) {
                message.signature = data.signature;
            }
            if (data.session_key != null) {
                message.session_key = data.session_key;
            }
            if (data.remote_attestation != null) {
                message.remote_attestation = data.remote_attestation;
            }
            if (data.service_version_info != null) {
                message.service_version_info = VersionInfo.fromObject(data.service_version_info);
            }
            if (data.session_key_type != null) {
                message.session_key_type = data.session_key_type;
            }
            if (data.oemcrypto_core_message != null) {
                message.oemcrypto_core_message = data.oemcrypto_core_message;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: SignedMessage.MessageType;
                msg?: Uint8Array;
                signature?: Uint8Array;
                session_key?: Uint8Array;
                remote_attestation?: Uint8Array;
                metric_data?: ReturnType<typeof MetricData.prototype.toObject>[];
                service_version_info?: ReturnType<typeof VersionInfo.prototype.toObject>;
                session_key_type?: SignedMessage.SessionKeyType;
                oemcrypto_core_message?: Uint8Array;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.msg != null) {
                data.msg = this.msg;
            }
            if (this.signature != null) {
                data.signature = this.signature;
            }
            if (this.session_key != null) {
                data.session_key = this.session_key;
            }
            if (this.remote_attestation != null) {
                data.remote_attestation = this.remote_attestation;
            }
            if (this.metric_data != null) {
                data.metric_data = this.metric_data.map((item: MetricData) => item.toObject());
            }
            if (this.service_version_info != null) {
                data.service_version_info = this.service_version_info.toObject();
            }
            if (this.session_key_type != null) {
                data.session_key_type = this.session_key_type;
            }
            if (this.oemcrypto_core_message != null) {
                data.oemcrypto_core_message = this.oemcrypto_core_message;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_type)
                writer.writeEnum(1, this.type);
            if (this.has_msg && this.msg.length)
                writer.writeBytes(2, this.msg);
            if (this.has_signature && this.signature.length)
                writer.writeBytes(3, this.signature);
            if (this.has_session_key && this.session_key.length)
                writer.writeBytes(4, this.session_key);
            if (this.has_remote_attestation && this.remote_attestation.length)
                writer.writeBytes(5, this.remote_attestation);
            if (this.metric_data.length)
                writer.writeRepeatedMessage(6, this.metric_data, (item: MetricData) => item.serialize(writer));
            if (this.has_service_version_info)
                writer.writeMessage(7, this.service_version_info, () => this.service_version_info.serialize(writer));
            if (this.has_session_key_type)
                writer.writeEnum(8, this.session_key_type);
            if (this.has_oemcrypto_core_message && this.oemcrypto_core_message.length)
                writer.writeBytes(9, this.oemcrypto_core_message);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignedMessage {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignedMessage();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.msg = reader.readBytes();
                        break;
                    case 3:
                        message.signature = reader.readBytes();
                        break;
                    case 4:
                        message.session_key = reader.readBytes();
                        break;
                    case 5:
                        message.remote_attestation = reader.readBytes();
                        break;
                    case 6:
                        reader.readMessage(message.metric_data, () => pb_1.Message.addToRepeatedWrapperField(message, 6, MetricData.deserialize(reader), MetricData));
                        break;
                    case 7:
                        reader.readMessage(message.service_version_info, () => message.service_version_info = VersionInfo.deserialize(reader));
                        break;
                    case 8:
                        message.session_key_type = reader.readEnum();
                        break;
                    case 9:
                        message.oemcrypto_core_message = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignedMessage {
            return SignedMessage.deserialize(bytes);
        }
    }
    export namespace SignedMessage {
        export enum MessageType {
            LICENSE_REQUEST = 1,
            LICENSE = 2,
            ERROR_RESPONSE = 3,
            SERVICE_CERTIFICATE_REQUEST = 4,
            SERVICE_CERTIFICATE = 5,
            SUB_LICENSE = 6,
            CAS_LICENSE_REQUEST = 7,
            CAS_LICENSE = 8,
            EXTERNAL_LICENSE_REQUEST = 9,
            EXTERNAL_LICENSE = 10
        }
        export enum SessionKeyType {
            UNDEFINED = 0,
            WRAPPED_AES_KEY = 1,
            EPHERMERAL_ECC_PUBLIC_KEY = 2
        }
    }
    export class ClientIdentification extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: ClientIdentification.TokenType;
            token?: Uint8Array;
            client_info: ClientIdentification.NameValue[];
            provider_client_token?: Uint8Array;
            license_counter?: number;
            client_capabilities?: ClientIdentification.ClientCapabilities;
            vmp_data?: Uint8Array;
            device_credentials: ClientIdentification.ClientCredentials[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3, 8], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("token" in data && data.token != undefined) {
                    this.token = data.token;
                }
                this.client_info = data.client_info;
                if ("provider_client_token" in data && data.provider_client_token != undefined) {
                    this.provider_client_token = data.provider_client_token;
                }
                if ("license_counter" in data && data.license_counter != undefined) {
                    this.license_counter = data.license_counter;
                }
                if ("client_capabilities" in data && data.client_capabilities != undefined) {
                    this.client_capabilities = data.client_capabilities;
                }
                if ("vmp_data" in data && data.vmp_data != undefined) {
                    this.vmp_data = data.vmp_data;
                }
                this.device_credentials = data.device_credentials;
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, ClientIdentification.TokenType.KEYBOX) as ClientIdentification.TokenType;
        }
        set type(value: ClientIdentification.TokenType) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_type() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get token() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set token(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get has_token() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get client_info() {
            return pb_1.Message.getRepeatedWrapperField(this, ClientIdentification.NameValue, 3) as ClientIdentification.NameValue[];
        }
        set client_info(value: ClientIdentification.NameValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        get provider_client_token() {
            return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array(0)) as Uint8Array;
        }
        set provider_client_token(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get has_provider_client_token() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get license_counter() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set license_counter(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get has_license_counter() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get client_capabilities() {
            return pb_1.Message.getWrapperField(this, ClientIdentification.ClientCapabilities, 6) as ClientIdentification.ClientCapabilities;
        }
        set client_capabilities(value: ClientIdentification.ClientCapabilities) {
            pb_1.Message.setWrapperField(this, 6, value);
        }
        get has_client_capabilities() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get vmp_data() {
            return pb_1.Message.getFieldWithDefault(this, 7, new Uint8Array(0)) as Uint8Array;
        }
        set vmp_data(value: Uint8Array) {
            pb_1.Message.setField(this, 7, value);
        }
        get has_vmp_data() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get device_credentials() {
            return pb_1.Message.getRepeatedWrapperField(this, ClientIdentification.ClientCredentials, 8) as ClientIdentification.ClientCredentials[];
        }
        set device_credentials(value: ClientIdentification.ClientCredentials[]) {
            pb_1.Message.setRepeatedWrapperField(this, 8, value);
        }
        static fromObject(data: {
            type?: ClientIdentification.TokenType;
            token?: Uint8Array;
            client_info?: ReturnType<typeof ClientIdentification.NameValue.prototype.toObject>[];
            provider_client_token?: Uint8Array;
            license_counter?: number;
            client_capabilities?: ReturnType<typeof ClientIdentification.ClientCapabilities.prototype.toObject>;
            vmp_data?: Uint8Array;
            device_credentials?: ReturnType<typeof ClientIdentification.ClientCredentials.prototype.toObject>[];
        }): ClientIdentification {
            const message = new ClientIdentification({
                client_info: data.client_info.map(item => ClientIdentification.NameValue.fromObject(item)),
                device_credentials: data.device_credentials.map(item => ClientIdentification.ClientCredentials.fromObject(item))
            });
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.token != null) {
                message.token = data.token;
            }
            if (data.provider_client_token != null) {
                message.provider_client_token = data.provider_client_token;
            }
            if (data.license_counter != null) {
                message.license_counter = data.license_counter;
            }
            if (data.client_capabilities != null) {
                message.client_capabilities = ClientIdentification.ClientCapabilities.fromObject(data.client_capabilities);
            }
            if (data.vmp_data != null) {
                message.vmp_data = data.vmp_data;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: ClientIdentification.TokenType;
                token?: Uint8Array;
                client_info?: ReturnType<typeof ClientIdentification.NameValue.prototype.toObject>[];
                provider_client_token?: Uint8Array;
                license_counter?: number;
                client_capabilities?: ReturnType<typeof ClientIdentification.ClientCapabilities.prototype.toObject>;
                vmp_data?: Uint8Array;
                device_credentials?: ReturnType<typeof ClientIdentification.ClientCredentials.prototype.toObject>[];
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.token != null) {
                data.token = this.token;
            }
            if (this.client_info != null) {
                data.client_info = this.client_info.map((item: ClientIdentification.NameValue) => item.toObject());
            }
            if (this.provider_client_token != null) {
                data.provider_client_token = this.provider_client_token;
            }
            if (this.license_counter != null) {
                data.license_counter = this.license_counter;
            }
            if (this.client_capabilities != null) {
                data.client_capabilities = this.client_capabilities.toObject();
            }
            if (this.vmp_data != null) {
                data.vmp_data = this.vmp_data;
            }
            if (this.device_credentials != null) {
                data.device_credentials = this.device_credentials.map((item: ClientIdentification.ClientCredentials) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_type)
                writer.writeEnum(1, this.type);
            if (this.has_token && this.token.length)
                writer.writeBytes(2, this.token);
            if (this.client_info.length)
                writer.writeRepeatedMessage(3, this.client_info, (item: ClientIdentification.NameValue) => item.serialize(writer));
            if (this.has_provider_client_token && this.provider_client_token.length)
                writer.writeBytes(4, this.provider_client_token);
            if (this.has_license_counter)
                writer.writeUint32(5, this.license_counter);
            if (this.has_client_capabilities)
                writer.writeMessage(6, this.client_capabilities, () => this.client_capabilities.serialize(writer));
            if (this.has_vmp_data && this.vmp_data.length)
                writer.writeBytes(7, this.vmp_data);
            if (this.device_credentials.length)
                writer.writeRepeatedMessage(8, this.device_credentials, (item: ClientIdentification.ClientCredentials) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ClientIdentification {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ClientIdentification();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.token = reader.readBytes();
                        break;
                    case 3:
                        reader.readMessage(message.client_info, () => pb_1.Message.addToRepeatedWrapperField(message, 3, ClientIdentification.NameValue.deserialize(reader), ClientIdentification.NameValue));
                        break;
                    case 4:
                        message.provider_client_token = reader.readBytes();
                        break;
                    case 5:
                        message.license_counter = reader.readUint32();
                        break;
                    case 6:
                        reader.readMessage(message.client_capabilities, () => message.client_capabilities = ClientIdentification.ClientCapabilities.deserialize(reader));
                        break;
                    case 7:
                        message.vmp_data = reader.readBytes();
                        break;
                    case 8:
                        reader.readMessage(message.device_credentials, () => pb_1.Message.addToRepeatedWrapperField(message, 8, ClientIdentification.ClientCredentials.deserialize(reader), ClientIdentification.ClientCredentials));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ClientIdentification {
            return ClientIdentification.deserialize(bytes);
        }
    }
    export namespace ClientIdentification {
        export enum TokenType {
            KEYBOX = 0,
            DRM_DEVICE_CERTIFICATE = 1,
            REMOTE_ATTESTATION_CERTIFICATE = 2,
            OEM_DEVICE_CERTIFICATE = 3
        }
        export class NameValue extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                name?: string;
                value?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("name" in data && data.name != undefined) {
                        this.name = data.name;
                    }
                    if ("value" in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get name() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set name(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get has_name() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get value() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set value(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get has_value() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                name?: string;
                value?: string;
            }): NameValue {
                const message = new NameValue({});
                if (data.name != null) {
                    message.name = data.name;
                }
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data: {
                    name?: string;
                    value?: string;
                } = {};
                if (this.name != null) {
                    data.name = this.name;
                }
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_name && this.name.length)
                    writer.writeString(1, this.name);
                if (this.has_value && this.value.length)
                    writer.writeString(2, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): NameValue {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new NameValue();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.name = reader.readString();
                            break;
                        case 2:
                            message.value = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): NameValue {
                return NameValue.deserialize(bytes);
            }
        }
        export class ClientCapabilities extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                client_token?: boolean;
                session_token?: boolean;
                video_resolution_constraints?: boolean;
                max_hdcp_version?: ClientIdentification.ClientCapabilities.HdcpVersion;
                oem_crypto_api_version?: number;
                anti_rollback_usage_table?: boolean;
                srm_version?: number;
                can_update_srm?: boolean;
                supported_certificate_key_type: ClientIdentification.ClientCapabilities.CertificateKeyType[];
                analog_output_capabilities?: ClientIdentification.ClientCapabilities.AnalogOutputCapabilities;
                can_disable_analog_output?: boolean;
                resource_rating_tier?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [9], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("client_token" in data && data.client_token != undefined) {
                        this.client_token = data.client_token;
                    }
                    if ("session_token" in data && data.session_token != undefined) {
                        this.session_token = data.session_token;
                    }
                    if ("video_resolution_constraints" in data && data.video_resolution_constraints != undefined) {
                        this.video_resolution_constraints = data.video_resolution_constraints;
                    }
                    if ("max_hdcp_version" in data && data.max_hdcp_version != undefined) {
                        this.max_hdcp_version = data.max_hdcp_version;
                    }
                    if ("oem_crypto_api_version" in data && data.oem_crypto_api_version != undefined) {
                        this.oem_crypto_api_version = data.oem_crypto_api_version;
                    }
                    if ("anti_rollback_usage_table" in data && data.anti_rollback_usage_table != undefined) {
                        this.anti_rollback_usage_table = data.anti_rollback_usage_table;
                    }
                    if ("srm_version" in data && data.srm_version != undefined) {
                        this.srm_version = data.srm_version;
                    }
                    if ("can_update_srm" in data && data.can_update_srm != undefined) {
                        this.can_update_srm = data.can_update_srm;
                    }
                    this.supported_certificate_key_type = data.supported_certificate_key_type;
                    if ("analog_output_capabilities" in data && data.analog_output_capabilities != undefined) {
                        this.analog_output_capabilities = data.analog_output_capabilities;
                    }
                    if ("can_disable_analog_output" in data && data.can_disable_analog_output != undefined) {
                        this.can_disable_analog_output = data.can_disable_analog_output;
                    }
                    if ("resource_rating_tier" in data && data.resource_rating_tier != undefined) {
                        this.resource_rating_tier = data.resource_rating_tier;
                    }
                }
            }
            get client_token() {
                return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
            }
            set client_token(value: boolean) {
                pb_1.Message.setField(this, 1, value);
            }
            get has_client_token() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get session_token() {
                return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
            }
            set session_token(value: boolean) {
                pb_1.Message.setField(this, 2, value);
            }
            get has_session_token() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get video_resolution_constraints() {
                return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
            }
            set video_resolution_constraints(value: boolean) {
                pb_1.Message.setField(this, 3, value);
            }
            get has_video_resolution_constraints() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get max_hdcp_version() {
                return pb_1.Message.getFieldWithDefault(this, 4, ClientIdentification.ClientCapabilities.HdcpVersion.HDCP_NONE) as ClientIdentification.ClientCapabilities.HdcpVersion;
            }
            set max_hdcp_version(value: ClientIdentification.ClientCapabilities.HdcpVersion) {
                pb_1.Message.setField(this, 4, value);
            }
            get has_max_hdcp_version() {
                return pb_1.Message.getField(this, 4) != null;
            }
            get oem_crypto_api_version() {
                return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
            }
            set oem_crypto_api_version(value: number) {
                pb_1.Message.setField(this, 5, value);
            }
            get has_oem_crypto_api_version() {
                return pb_1.Message.getField(this, 5) != null;
            }
            get anti_rollback_usage_table() {
                return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
            }
            set anti_rollback_usage_table(value: boolean) {
                pb_1.Message.setField(this, 6, value);
            }
            get has_anti_rollback_usage_table() {
                return pb_1.Message.getField(this, 6) != null;
            }
            get srm_version() {
                return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
            }
            set srm_version(value: number) {
                pb_1.Message.setField(this, 7, value);
            }
            get has_srm_version() {
                return pb_1.Message.getField(this, 7) != null;
            }
            get can_update_srm() {
                return pb_1.Message.getFieldWithDefault(this, 8, false) as boolean;
            }
            set can_update_srm(value: boolean) {
                pb_1.Message.setField(this, 8, value);
            }
            get has_can_update_srm() {
                return pb_1.Message.getField(this, 8) != null;
            }
            get supported_certificate_key_type() {
                return pb_1.Message.getFieldWithDefault(this, 9, []) as ClientIdentification.ClientCapabilities.CertificateKeyType[];
            }
            set supported_certificate_key_type(value: ClientIdentification.ClientCapabilities.CertificateKeyType[]) {
                pb_1.Message.setField(this, 9, value);
            }
            get analog_output_capabilities() {
                return pb_1.Message.getFieldWithDefault(this, 10, ClientIdentification.ClientCapabilities.AnalogOutputCapabilities.ANALOG_OUTPUT_UNKNOWN) as ClientIdentification.ClientCapabilities.AnalogOutputCapabilities;
            }
            set analog_output_capabilities(value: ClientIdentification.ClientCapabilities.AnalogOutputCapabilities) {
                pb_1.Message.setField(this, 10, value);
            }
            get has_analog_output_capabilities() {
                return pb_1.Message.getField(this, 10) != null;
            }
            get can_disable_analog_output() {
                return pb_1.Message.getFieldWithDefault(this, 11, false) as boolean;
            }
            set can_disable_analog_output(value: boolean) {
                pb_1.Message.setField(this, 11, value);
            }
            get has_can_disable_analog_output() {
                return pb_1.Message.getField(this, 11) != null;
            }
            get resource_rating_tier() {
                return pb_1.Message.getFieldWithDefault(this, 12, 0) as number;
            }
            set resource_rating_tier(value: number) {
                pb_1.Message.setField(this, 12, value);
            }
            get has_resource_rating_tier() {
                return pb_1.Message.getField(this, 12) != null;
            }
            static fromObject(data: {
                client_token?: boolean;
                session_token?: boolean;
                video_resolution_constraints?: boolean;
                max_hdcp_version?: ClientIdentification.ClientCapabilities.HdcpVersion;
                oem_crypto_api_version?: number;
                anti_rollback_usage_table?: boolean;
                srm_version?: number;
                can_update_srm?: boolean;
                supported_certificate_key_type: ClientIdentification.ClientCapabilities.CertificateKeyType[];
                analog_output_capabilities?: ClientIdentification.ClientCapabilities.AnalogOutputCapabilities;
                can_disable_analog_output?: boolean;
                resource_rating_tier?: number;
            }): ClientCapabilities {
                const message = new ClientCapabilities({
                    supported_certificate_key_type: data.supported_certificate_key_type
                });
                if (data.client_token != null) {
                    message.client_token = data.client_token;
                }
                if (data.session_token != null) {
                    message.session_token = data.session_token;
                }
                if (data.video_resolution_constraints != null) {
                    message.video_resolution_constraints = data.video_resolution_constraints;
                }
                if (data.max_hdcp_version != null) {
                    message.max_hdcp_version = data.max_hdcp_version;
                }
                if (data.oem_crypto_api_version != null) {
                    message.oem_crypto_api_version = data.oem_crypto_api_version;
                }
                if (data.anti_rollback_usage_table != null) {
                    message.anti_rollback_usage_table = data.anti_rollback_usage_table;
                }
                if (data.srm_version != null) {
                    message.srm_version = data.srm_version;
                }
                if (data.can_update_srm != null) {
                    message.can_update_srm = data.can_update_srm;
                }
                if (data.analog_output_capabilities != null) {
                    message.analog_output_capabilities = data.analog_output_capabilities;
                }
                if (data.can_disable_analog_output != null) {
                    message.can_disable_analog_output = data.can_disable_analog_output;
                }
                if (data.resource_rating_tier != null) {
                    message.resource_rating_tier = data.resource_rating_tier;
                }
                return message;
            }
            toObject() {
                const data: {
                    client_token?: boolean;
                    session_token?: boolean;
                    video_resolution_constraints?: boolean;
                    max_hdcp_version?: ClientIdentification.ClientCapabilities.HdcpVersion;
                    oem_crypto_api_version?: number;
                    anti_rollback_usage_table?: boolean;
                    srm_version?: number;
                    can_update_srm?: boolean;
                    supported_certificate_key_type: ClientIdentification.ClientCapabilities.CertificateKeyType[];
                    analog_output_capabilities?: ClientIdentification.ClientCapabilities.AnalogOutputCapabilities;
                    can_disable_analog_output?: boolean;
                    resource_rating_tier?: number;
                } = {
                    supported_certificate_key_type: this.supported_certificate_key_type
                };
                if (this.client_token != null) {
                    data.client_token = this.client_token;
                }
                if (this.session_token != null) {
                    data.session_token = this.session_token;
                }
                if (this.video_resolution_constraints != null) {
                    data.video_resolution_constraints = this.video_resolution_constraints;
                }
                if (this.max_hdcp_version != null) {
                    data.max_hdcp_version = this.max_hdcp_version;
                }
                if (this.oem_crypto_api_version != null) {
                    data.oem_crypto_api_version = this.oem_crypto_api_version;
                }
                if (this.anti_rollback_usage_table != null) {
                    data.anti_rollback_usage_table = this.anti_rollback_usage_table;
                }
                if (this.srm_version != null) {
                    data.srm_version = this.srm_version;
                }
                if (this.can_update_srm != null) {
                    data.can_update_srm = this.can_update_srm;
                }
                if (this.analog_output_capabilities != null) {
                    data.analog_output_capabilities = this.analog_output_capabilities;
                }
                if (this.can_disable_analog_output != null) {
                    data.can_disable_analog_output = this.can_disable_analog_output;
                }
                if (this.resource_rating_tier != null) {
                    data.resource_rating_tier = this.resource_rating_tier;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_client_token)
                    writer.writeBool(1, this.client_token);
                if (this.has_session_token)
                    writer.writeBool(2, this.session_token);
                if (this.has_video_resolution_constraints)
                    writer.writeBool(3, this.video_resolution_constraints);
                if (this.has_max_hdcp_version)
                    writer.writeEnum(4, this.max_hdcp_version);
                if (this.has_oem_crypto_api_version)
                    writer.writeUint32(5, this.oem_crypto_api_version);
                if (this.has_anti_rollback_usage_table)
                    writer.writeBool(6, this.anti_rollback_usage_table);
                if (this.has_srm_version)
                    writer.writeUint32(7, this.srm_version);
                if (this.has_can_update_srm)
                    writer.writeBool(8, this.can_update_srm);
                if (this.supported_certificate_key_type.length)
                    writer.writeRepeatedEnum(9, this.supported_certificate_key_type);
                if (this.has_analog_output_capabilities)
                    writer.writeEnum(10, this.analog_output_capabilities);
                if (this.has_can_disable_analog_output)
                    writer.writeBool(11, this.can_disable_analog_output);
                if (this.has_resource_rating_tier)
                    writer.writeUint32(12, this.resource_rating_tier);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ClientCapabilities {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ClientCapabilities();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.client_token = reader.readBool();
                            break;
                        case 2:
                            message.session_token = reader.readBool();
                            break;
                        case 3:
                            message.video_resolution_constraints = reader.readBool();
                            break;
                        case 4:
                            message.max_hdcp_version = reader.readEnum();
                            break;
                        case 5:
                            message.oem_crypto_api_version = reader.readUint32();
                            break;
                        case 6:
                            message.anti_rollback_usage_table = reader.readBool();
                            break;
                        case 7:
                            message.srm_version = reader.readUint32();
                            break;
                        case 8:
                            message.can_update_srm = reader.readBool();
                            break;
                        case 9:
                            pb_1.Message.addToRepeatedField(message, 9, reader.readEnum());
                            break;
                        case 10:
                            message.analog_output_capabilities = reader.readEnum();
                            break;
                        case 11:
                            message.can_disable_analog_output = reader.readBool();
                            break;
                        case 12:
                            message.resource_rating_tier = reader.readUint32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): ClientCapabilities {
                return ClientCapabilities.deserialize(bytes);
            }
        }
        export namespace ClientCapabilities {
            export enum HdcpVersion {
                HDCP_NONE = 0,
                HDCP_V1 = 1,
                HDCP_V2 = 2,
                HDCP_V2_1 = 3,
                HDCP_V2_2 = 4,
                HDCP_V2_3 = 5,
                HDCP_NO_DIGITAL_OUTPUT = 255
            }
            export enum CertificateKeyType {
                RSA_2048 = 0,
                RSA_3072 = 1,
                ECC_SECP256R1 = 2,
                ECC_SECP384R1 = 3,
                ECC_SECP521R1 = 4
            }
            export enum AnalogOutputCapabilities {
                ANALOG_OUTPUT_UNKNOWN = 0,
                ANALOG_OUTPUT_NONE = 1,
                ANALOG_OUTPUT_SUPPORTED = 2,
                ANALOG_OUTPUT_SUPPORTS_CGMS_A = 3
            }
        }
        export class ClientCredentials extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                type?: ClientIdentification.TokenType;
                token?: Uint8Array;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("token" in data && data.token != undefined) {
                        this.token = data.token;
                    }
                }
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 1, ClientIdentification.TokenType.KEYBOX) as ClientIdentification.TokenType;
            }
            set type(value: ClientIdentification.TokenType) {
                pb_1.Message.setField(this, 1, value);
            }
            get has_type() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get token() {
                return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
            }
            set token(value: Uint8Array) {
                pb_1.Message.setField(this, 2, value);
            }
            get has_token() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                type?: ClientIdentification.TokenType;
                token?: Uint8Array;
            }): ClientCredentials {
                const message = new ClientCredentials({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.token != null) {
                    message.token = data.token;
                }
                return message;
            }
            toObject() {
                const data: {
                    type?: ClientIdentification.TokenType;
                    token?: Uint8Array;
                } = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.token != null) {
                    data.token = this.token;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_type)
                    writer.writeEnum(1, this.type);
                if (this.has_token && this.token.length)
                    writer.writeBytes(2, this.token);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ClientCredentials {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ClientCredentials();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readEnum();
                            break;
                        case 2:
                            message.token = reader.readBytes();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): ClientCredentials {
                return ClientCredentials.deserialize(bytes);
            }
        }
    }
    export class EncryptedClientIdentification extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            provider_id?: string;
            service_certificate_serial_number?: Uint8Array;
            encrypted_client_id?: Uint8Array;
            encrypted_client_id_iv?: Uint8Array;
            encrypted_privacy_key?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("provider_id" in data && data.provider_id != undefined) {
                    this.provider_id = data.provider_id;
                }
                if ("service_certificate_serial_number" in data && data.service_certificate_serial_number != undefined) {
                    this.service_certificate_serial_number = data.service_certificate_serial_number;
                }
                if ("encrypted_client_id" in data && data.encrypted_client_id != undefined) {
                    this.encrypted_client_id = data.encrypted_client_id;
                }
                if ("encrypted_client_id_iv" in data && data.encrypted_client_id_iv != undefined) {
                    this.encrypted_client_id_iv = data.encrypted_client_id_iv;
                }
                if ("encrypted_privacy_key" in data && data.encrypted_privacy_key != undefined) {
                    this.encrypted_privacy_key = data.encrypted_privacy_key;
                }
            }
        }
        get provider_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set provider_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_provider_id() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get service_certificate_serial_number() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set service_certificate_serial_number(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get has_service_certificate_serial_number() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get encrypted_client_id() {
            return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
        }
        set encrypted_client_id(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        get has_encrypted_client_id() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get encrypted_client_id_iv() {
            return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array(0)) as Uint8Array;
        }
        set encrypted_client_id_iv(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get has_encrypted_client_id_iv() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get encrypted_privacy_key() {
            return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
        }
        set encrypted_privacy_key(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get has_encrypted_privacy_key() {
            return pb_1.Message.getField(this, 5) != null;
        }
        static fromObject(data: {
            provider_id?: string;
            service_certificate_serial_number?: Uint8Array;
            encrypted_client_id?: Uint8Array;
            encrypted_client_id_iv?: Uint8Array;
            encrypted_privacy_key?: Uint8Array;
        }): EncryptedClientIdentification {
            const message = new EncryptedClientIdentification({});
            if (data.provider_id != null) {
                message.provider_id = data.provider_id;
            }
            if (data.service_certificate_serial_number != null) {
                message.service_certificate_serial_number = data.service_certificate_serial_number;
            }
            if (data.encrypted_client_id != null) {
                message.encrypted_client_id = data.encrypted_client_id;
            }
            if (data.encrypted_client_id_iv != null) {
                message.encrypted_client_id_iv = data.encrypted_client_id_iv;
            }
            if (data.encrypted_privacy_key != null) {
                message.encrypted_privacy_key = data.encrypted_privacy_key;
            }
            return message;
        }
        toObject() {
            const data: {
                provider_id?: string;
                service_certificate_serial_number?: Uint8Array;
                encrypted_client_id?: Uint8Array;
                encrypted_client_id_iv?: Uint8Array;
                encrypted_privacy_key?: Uint8Array;
            } = {};
            if (this.provider_id != null) {
                data.provider_id = this.provider_id;
            }
            if (this.service_certificate_serial_number != null) {
                data.service_certificate_serial_number = this.service_certificate_serial_number;
            }
            if (this.encrypted_client_id != null) {
                data.encrypted_client_id = this.encrypted_client_id;
            }
            if (this.encrypted_client_id_iv != null) {
                data.encrypted_client_id_iv = this.encrypted_client_id_iv;
            }
            if (this.encrypted_privacy_key != null) {
                data.encrypted_privacy_key = this.encrypted_privacy_key;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_provider_id && this.provider_id.length)
                writer.writeString(1, this.provider_id);
            if (this.has_service_certificate_serial_number && this.service_certificate_serial_number.length)
                writer.writeBytes(2, this.service_certificate_serial_number);
            if (this.has_encrypted_client_id && this.encrypted_client_id.length)
                writer.writeBytes(3, this.encrypted_client_id);
            if (this.has_encrypted_client_id_iv && this.encrypted_client_id_iv.length)
                writer.writeBytes(4, this.encrypted_client_id_iv);
            if (this.has_encrypted_privacy_key && this.encrypted_privacy_key.length)
                writer.writeBytes(5, this.encrypted_privacy_key);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EncryptedClientIdentification {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EncryptedClientIdentification();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.provider_id = reader.readString();
                        break;
                    case 2:
                        message.service_certificate_serial_number = reader.readBytes();
                        break;
                    case 3:
                        message.encrypted_client_id = reader.readBytes();
                        break;
                    case 4:
                        message.encrypted_client_id_iv = reader.readBytes();
                        break;
                    case 5:
                        message.encrypted_privacy_key = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EncryptedClientIdentification {
            return EncryptedClientIdentification.deserialize(bytes);
        }
    }
    export class DrmCertificate extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: DrmCertificate.Type;
            serial_number?: Uint8Array;
            creation_time_seconds?: number;
            expiration_time_seconds?: number;
            public_key?: Uint8Array;
            system_id?: number;
            /** @deprecated*/
            test_device_deprecated?: boolean;
            provider_id?: string;
            service_types: DrmCertificate.ServiceType[];
            algorithm?: DrmCertificate.Algorithm;
            rot_id?: Uint8Array;
            encryption_key?: DrmCertificate.EncryptionKey;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [8], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("serial_number" in data && data.serial_number != undefined) {
                    this.serial_number = data.serial_number;
                }
                if ("creation_time_seconds" in data && data.creation_time_seconds != undefined) {
                    this.creation_time_seconds = data.creation_time_seconds;
                }
                if ("expiration_time_seconds" in data && data.expiration_time_seconds != undefined) {
                    this.expiration_time_seconds = data.expiration_time_seconds;
                }
                if ("public_key" in data && data.public_key != undefined) {
                    this.public_key = data.public_key;
                }
                if ("system_id" in data && data.system_id != undefined) {
                    this.system_id = data.system_id;
                }
                if ("test_device_deprecated" in data && data.test_device_deprecated != undefined) {
                    this.test_device_deprecated = data.test_device_deprecated;
                }
                if ("provider_id" in data && data.provider_id != undefined) {
                    this.provider_id = data.provider_id;
                }
                this.service_types = data.service_types;
                if ("algorithm" in data && data.algorithm != undefined) {
                    this.algorithm = data.algorithm;
                }
                if ("rot_id" in data && data.rot_id != undefined) {
                    this.rot_id = data.rot_id;
                }
                if ("encryption_key" in data && data.encryption_key != undefined) {
                    this.encryption_key = data.encryption_key;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, DrmCertificate.Type.ROOT) as DrmCertificate.Type;
        }
        set type(value: DrmCertificate.Type) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_type() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get serial_number() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set serial_number(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get has_serial_number() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get creation_time_seconds() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set creation_time_seconds(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get has_creation_time_seconds() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get expiration_time_seconds() {
            return pb_1.Message.getFieldWithDefault(this, 12, 0) as number;
        }
        set expiration_time_seconds(value: number) {
            pb_1.Message.setField(this, 12, value);
        }
        get has_expiration_time_seconds() {
            return pb_1.Message.getField(this, 12) != null;
        }
        get public_key() {
            return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array(0)) as Uint8Array;
        }
        set public_key(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get has_public_key() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get system_id() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set system_id(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get has_system_id() {
            return pb_1.Message.getField(this, 5) != null;
        }
        /** @deprecated*/
        get test_device_deprecated() {
            return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
        }
        /** @deprecated*/
        set test_device_deprecated(value: boolean) {
            pb_1.Message.setField(this, 6, value);
        }
        /** @deprecated*/
        get has_test_device_deprecated() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get provider_id() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set provider_id(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get has_provider_id() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get service_types() {
            return pb_1.Message.getFieldWithDefault(this, 8, []) as DrmCertificate.ServiceType[];
        }
        set service_types(value: DrmCertificate.ServiceType[]) {
            pb_1.Message.setField(this, 8, value);
        }
        get algorithm() {
            return pb_1.Message.getFieldWithDefault(this, 9, DrmCertificate.Algorithm.RSA) as DrmCertificate.Algorithm;
        }
        set algorithm(value: DrmCertificate.Algorithm) {
            pb_1.Message.setField(this, 9, value);
        }
        get has_algorithm() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get rot_id() {
            return pb_1.Message.getFieldWithDefault(this, 10, new Uint8Array(0)) as Uint8Array;
        }
        set rot_id(value: Uint8Array) {
            pb_1.Message.setField(this, 10, value);
        }
        get has_rot_id() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get encryption_key() {
            return pb_1.Message.getWrapperField(this, DrmCertificate.EncryptionKey, 11) as DrmCertificate.EncryptionKey;
        }
        set encryption_key(value: DrmCertificate.EncryptionKey) {
            pb_1.Message.setWrapperField(this, 11, value);
        }
        get has_encryption_key() {
            return pb_1.Message.getField(this, 11) != null;
        }
        static fromObject(data: {
            type?: DrmCertificate.Type;
            serial_number?: Uint8Array;
            creation_time_seconds?: number;
            expiration_time_seconds?: number;
            public_key?: Uint8Array;
            system_id?: number;
            test_device_deprecated?: boolean;
            provider_id?: string;
            service_types: DrmCertificate.ServiceType[];
            algorithm?: DrmCertificate.Algorithm;
            rot_id?: Uint8Array;
            encryption_key?: ReturnType<typeof DrmCertificate.EncryptionKey.prototype.toObject>;
        }): DrmCertificate {
            const message = new DrmCertificate({
                service_types: data.service_types
            });
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.serial_number != null) {
                message.serial_number = data.serial_number;
            }
            if (data.creation_time_seconds != null) {
                message.creation_time_seconds = data.creation_time_seconds;
            }
            if (data.expiration_time_seconds != null) {
                message.expiration_time_seconds = data.expiration_time_seconds;
            }
            if (data.public_key != null) {
                message.public_key = data.public_key;
            }
            if (data.system_id != null) {
                message.system_id = data.system_id;
            }
            if (data.test_device_deprecated != null) {
                message.test_device_deprecated = data.test_device_deprecated;
            }
            if (data.provider_id != null) {
                message.provider_id = data.provider_id;
            }
            if (data.algorithm != null) {
                message.algorithm = data.algorithm;
            }
            if (data.rot_id != null) {
                message.rot_id = data.rot_id;
            }
            if (data.encryption_key != null) {
                message.encryption_key = DrmCertificate.EncryptionKey.fromObject(data.encryption_key);
            }
            return message;
        }
        toObject() {
            const data: {
                type?: DrmCertificate.Type;
                serial_number?: Uint8Array;
                creation_time_seconds?: number;
                expiration_time_seconds?: number;
                public_key?: Uint8Array;
                system_id?: number;
                test_device_deprecated?: boolean;
                provider_id?: string;
                service_types: DrmCertificate.ServiceType[];
                algorithm?: DrmCertificate.Algorithm;
                rot_id?: Uint8Array;
                encryption_key?: ReturnType<typeof DrmCertificate.EncryptionKey.prototype.toObject>;
            } = {
                service_types: this.service_types
            };
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.serial_number != null) {
                data.serial_number = this.serial_number;
            }
            if (this.creation_time_seconds != null) {
                data.creation_time_seconds = this.creation_time_seconds;
            }
            if (this.expiration_time_seconds != null) {
                data.expiration_time_seconds = this.expiration_time_seconds;
            }
            if (this.public_key != null) {
                data.public_key = this.public_key;
            }
            if (this.system_id != null) {
                data.system_id = this.system_id;
            }
            if (this.test_device_deprecated != null) {
                data.test_device_deprecated = this.test_device_deprecated;
            }
            if (this.provider_id != null) {
                data.provider_id = this.provider_id;
            }
            if (this.algorithm != null) {
                data.algorithm = this.algorithm;
            }
            if (this.rot_id != null) {
                data.rot_id = this.rot_id;
            }
            if (this.encryption_key != null) {
                data.encryption_key = this.encryption_key.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_type)
                writer.writeEnum(1, this.type);
            if (this.has_serial_number && this.serial_number.length)
                writer.writeBytes(2, this.serial_number);
            if (this.has_creation_time_seconds)
                writer.writeUint32(3, this.creation_time_seconds);
            if (this.has_expiration_time_seconds)
                writer.writeUint32(12, this.expiration_time_seconds);
            if (this.has_public_key && this.public_key.length)
                writer.writeBytes(4, this.public_key);
            if (this.has_system_id)
                writer.writeUint32(5, this.system_id);
            if (this.has_test_device_deprecated)
                writer.writeBool(6, this.test_device_deprecated);
            if (this.has_provider_id && this.provider_id.length)
                writer.writeString(7, this.provider_id);
            if (this.service_types.length)
                writer.writeRepeatedEnum(8, this.service_types);
            if (this.has_algorithm)
                writer.writeEnum(9, this.algorithm);
            if (this.has_rot_id && this.rot_id.length)
                writer.writeBytes(10, this.rot_id);
            if (this.has_encryption_key)
                writer.writeMessage(11, this.encryption_key, () => this.encryption_key.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DrmCertificate {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DrmCertificate();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.serial_number = reader.readBytes();
                        break;
                    case 3:
                        message.creation_time_seconds = reader.readUint32();
                        break;
                    case 12:
                        message.expiration_time_seconds = reader.readUint32();
                        break;
                    case 4:
                        message.public_key = reader.readBytes();
                        break;
                    case 5:
                        message.system_id = reader.readUint32();
                        break;
                    case 6:
                        message.test_device_deprecated = reader.readBool();
                        break;
                    case 7:
                        message.provider_id = reader.readString();
                        break;
                    case 8:
                        pb_1.Message.addToRepeatedField(message, 8, reader.readEnum());
                        break;
                    case 9:
                        message.algorithm = reader.readEnum();
                        break;
                    case 10:
                        message.rot_id = reader.readBytes();
                        break;
                    case 11:
                        reader.readMessage(message.encryption_key, () => message.encryption_key = DrmCertificate.EncryptionKey.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DrmCertificate {
            return DrmCertificate.deserialize(bytes);
        }
    }
    export namespace DrmCertificate {
        export enum Type {
            ROOT = 0,
            DEVICE_MODEL = 1,
            DEVICE = 2,
            SERVICE = 3,
            PROVISIONER = 4
        }
        export enum ServiceType {
            UNKNOWN_SERVICE_TYPE = 0,
            LICENSE_SERVER_SDK = 1,
            LICENSE_SERVER_PROXY_SDK = 2,
            PROVISIONING_SDK = 3,
            CAS_PROXY_SDK = 4
        }
        export enum Algorithm {
            UNKNOWN_ALGORITHM = 0,
            RSA = 1,
            ECC_SECP256R1 = 2,
            ECC_SECP384R1 = 3,
            ECC_SECP521R1 = 4
        }
        export class EncryptionKey extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                public_key?: Uint8Array;
                algorithm?: DrmCertificate.Algorithm;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("public_key" in data && data.public_key != undefined) {
                        this.public_key = data.public_key;
                    }
                    if ("algorithm" in data && data.algorithm != undefined) {
                        this.algorithm = data.algorithm;
                    }
                }
            }
            get public_key() {
                return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
            }
            set public_key(value: Uint8Array) {
                pb_1.Message.setField(this, 1, value);
            }
            get has_public_key() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get algorithm() {
                return pb_1.Message.getFieldWithDefault(this, 2, DrmCertificate.Algorithm.RSA) as DrmCertificate.Algorithm;
            }
            set algorithm(value: DrmCertificate.Algorithm) {
                pb_1.Message.setField(this, 2, value);
            }
            get has_algorithm() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                public_key?: Uint8Array;
                algorithm?: DrmCertificate.Algorithm;
            }): EncryptionKey {
                const message = new EncryptionKey({});
                if (data.public_key != null) {
                    message.public_key = data.public_key;
                }
                if (data.algorithm != null) {
                    message.algorithm = data.algorithm;
                }
                return message;
            }
            toObject() {
                const data: {
                    public_key?: Uint8Array;
                    algorithm?: DrmCertificate.Algorithm;
                } = {};
                if (this.public_key != null) {
                    data.public_key = this.public_key;
                }
                if (this.algorithm != null) {
                    data.algorithm = this.algorithm;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_public_key && this.public_key.length)
                    writer.writeBytes(1, this.public_key);
                if (this.has_algorithm)
                    writer.writeEnum(2, this.algorithm);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EncryptionKey {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EncryptionKey();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.public_key = reader.readBytes();
                            break;
                        case 2:
                            message.algorithm = reader.readEnum();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): EncryptionKey {
                return EncryptionKey.deserialize(bytes);
            }
        }
    }
    export class SignedDrmCertificate extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            drm_certificate?: Uint8Array;
            signature?: Uint8Array;
            signer?: SignedDrmCertificate;
            hash_algorithm?: HashAlgorithmProto;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("drm_certificate" in data && data.drm_certificate != undefined) {
                    this.drm_certificate = data.drm_certificate;
                }
                if ("signature" in data && data.signature != undefined) {
                    this.signature = data.signature;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
                if ("hash_algorithm" in data && data.hash_algorithm != undefined) {
                    this.hash_algorithm = data.hash_algorithm;
                }
            }
        }
        get drm_certificate() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set drm_certificate(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_drm_certificate() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get signature() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set signature(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get has_signature() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get signer() {
            return pb_1.Message.getWrapperField(this, SignedDrmCertificate, 3) as SignedDrmCertificate;
        }
        set signer(value: SignedDrmCertificate) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_signer() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get hash_algorithm() {
            return pb_1.Message.getFieldWithDefault(this, 4, HashAlgorithmProto.HASH_ALGORITHM_UNSPECIFIED) as HashAlgorithmProto;
        }
        set hash_algorithm(value: HashAlgorithmProto) {
            pb_1.Message.setField(this, 4, value);
        }
        get has_hash_algorithm() {
            return pb_1.Message.getField(this, 4) != null;
        }
        static fromObject(data: {
            drm_certificate?: Uint8Array;
            signature?: Uint8Array;
            signer?: ReturnType<typeof SignedDrmCertificate.prototype.toObject>;
            hash_algorithm?: HashAlgorithmProto;
        }): SignedDrmCertificate {
            const message = new SignedDrmCertificate({});
            if (data.drm_certificate != null) {
                message.drm_certificate = data.drm_certificate;
            }
            if (data.signature != null) {
                message.signature = data.signature;
            }
            if (data.signer != null) {
                message.signer = SignedDrmCertificate.fromObject(data.signer);
            }
            if (data.hash_algorithm != null) {
                message.hash_algorithm = data.hash_algorithm;
            }
            return message;
        }
        toObject() {
            const data: {
                drm_certificate?: Uint8Array;
                signature?: Uint8Array;
                signer?: ReturnType<typeof SignedDrmCertificate.prototype.toObject>;
                hash_algorithm?: HashAlgorithmProto;
            } = {};
            if (this.drm_certificate != null) {
                data.drm_certificate = this.drm_certificate;
            }
            if (this.signature != null) {
                data.signature = this.signature;
            }
            if (this.signer != null) {
                data.signer = this.signer.toObject();
            }
            if (this.hash_algorithm != null) {
                data.hash_algorithm = this.hash_algorithm;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_drm_certificate && this.drm_certificate.length)
                writer.writeBytes(1, this.drm_certificate);
            if (this.has_signature && this.signature.length)
                writer.writeBytes(2, this.signature);
            if (this.has_signer)
                writer.writeMessage(3, this.signer, () => this.signer.serialize(writer));
            if (this.has_hash_algorithm)
                writer.writeEnum(4, this.hash_algorithm);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignedDrmCertificate {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignedDrmCertificate();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.drm_certificate = reader.readBytes();
                        break;
                    case 2:
                        message.signature = reader.readBytes();
                        break;
                    case 3:
                        reader.readMessage(message.signer, () => message.signer = SignedDrmCertificate.deserialize(reader));
                        break;
                    case 4:
                        message.hash_algorithm = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignedDrmCertificate {
            return SignedDrmCertificate.deserialize(bytes);
        }
    }
    export class WidevinePsshData extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            key_ids: Uint8Array[];
            content_id?: Uint8Array;
            crypto_period_index?: number;
            protection_scheme?: number;
            crypto_period_seconds?: number;
            type?: WidevinePsshData.Type;
            key_sequence?: number;
            group_ids: Uint8Array[];
            entitled_keys: WidevinePsshData.EntitledKey[];
            video_feature?: string;
            /** @deprecated*/
            algorithm?: WidevinePsshData.Algorithm;
            /** @deprecated*/
            provider?: string;
            /** @deprecated*/
            track_type?: string;
            /** @deprecated*/
            policy?: string;
            /** @deprecated*/
            grouped_license?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 13, 14], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.key_ids = data.key_ids;
                if ("content_id" in data && data.content_id != undefined) {
                    this.content_id = data.content_id;
                }
                if ("crypto_period_index" in data && data.crypto_period_index != undefined) {
                    this.crypto_period_index = data.crypto_period_index;
                }
                if ("protection_scheme" in data && data.protection_scheme != undefined) {
                    this.protection_scheme = data.protection_scheme;
                }
                if ("crypto_period_seconds" in data && data.crypto_period_seconds != undefined) {
                    this.crypto_period_seconds = data.crypto_period_seconds;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("key_sequence" in data && data.key_sequence != undefined) {
                    this.key_sequence = data.key_sequence;
                }
                this.group_ids = data.group_ids;
                this.entitled_keys = data.entitled_keys;
                if ("video_feature" in data && data.video_feature != undefined) {
                    this.video_feature = data.video_feature;
                }
                if ("algorithm" in data && data.algorithm != undefined) {
                    this.algorithm = data.algorithm;
                }
                if ("provider" in data && data.provider != undefined) {
                    this.provider = data.provider;
                }
                if ("track_type" in data && data.track_type != undefined) {
                    this.track_type = data.track_type;
                }
                if ("policy" in data && data.policy != undefined) {
                    this.policy = data.policy;
                }
                if ("grouped_license" in data && data.grouped_license != undefined) {
                    this.grouped_license = data.grouped_license;
                }
            }
        }
        get key_ids() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as Uint8Array[];
        }
        set key_ids(value: Uint8Array[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get content_id() {
            return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array(0)) as Uint8Array;
        }
        set content_id(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get has_content_id() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get crypto_period_index() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set crypto_period_index(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get has_crypto_period_index() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get protection_scheme() {
            return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
        }
        set protection_scheme(value: number) {
            pb_1.Message.setField(this, 9, value);
        }
        get has_protection_scheme() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get crypto_period_seconds() {
            return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
        }
        set crypto_period_seconds(value: number) {
            pb_1.Message.setField(this, 10, value);
        }
        get has_crypto_period_seconds() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 11, WidevinePsshData.Type.SINGLE) as WidevinePsshData.Type;
        }
        set type(value: WidevinePsshData.Type) {
            pb_1.Message.setField(this, 11, value);
        }
        get has_type() {
            return pb_1.Message.getField(this, 11) != null;
        }
        get key_sequence() {
            return pb_1.Message.getFieldWithDefault(this, 12, 0) as number;
        }
        set key_sequence(value: number) {
            pb_1.Message.setField(this, 12, value);
        }
        get has_key_sequence() {
            return pb_1.Message.getField(this, 12) != null;
        }
        get group_ids() {
            return pb_1.Message.getFieldWithDefault(this, 13, []) as Uint8Array[];
        }
        set group_ids(value: Uint8Array[]) {
            pb_1.Message.setField(this, 13, value);
        }
        get entitled_keys() {
            return pb_1.Message.getRepeatedWrapperField(this, WidevinePsshData.EntitledKey, 14) as WidevinePsshData.EntitledKey[];
        }
        set entitled_keys(value: WidevinePsshData.EntitledKey[]) {
            pb_1.Message.setRepeatedWrapperField(this, 14, value);
        }
        get video_feature() {
            return pb_1.Message.getFieldWithDefault(this, 15, "") as string;
        }
        set video_feature(value: string) {
            pb_1.Message.setField(this, 15, value);
        }
        get has_video_feature() {
            return pb_1.Message.getField(this, 15) != null;
        }
        /** @deprecated*/
        get algorithm() {
            return pb_1.Message.getFieldWithDefault(this, 1, WidevinePsshData.Algorithm.UNENCRYPTED) as WidevinePsshData.Algorithm;
        }
        /** @deprecated*/
        set algorithm(value: WidevinePsshData.Algorithm) {
            pb_1.Message.setField(this, 1, value);
        }
        /** @deprecated*/
        get has_algorithm() {
            return pb_1.Message.getField(this, 1) != null;
        }
        /** @deprecated*/
        get provider() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        /** @deprecated*/
        set provider(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        /** @deprecated*/
        get has_provider() {
            return pb_1.Message.getField(this, 3) != null;
        }
        /** @deprecated*/
        get track_type() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        /** @deprecated*/
        set track_type(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        /** @deprecated*/
        get has_track_type() {
            return pb_1.Message.getField(this, 5) != null;
        }
        /** @deprecated*/
        get policy() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        /** @deprecated*/
        set policy(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        /** @deprecated*/
        get has_policy() {
            return pb_1.Message.getField(this, 6) != null;
        }
        /** @deprecated*/
        get grouped_license() {
            return pb_1.Message.getFieldWithDefault(this, 8, new Uint8Array(0)) as Uint8Array;
        }
        /** @deprecated*/
        set grouped_license(value: Uint8Array) {
            pb_1.Message.setField(this, 8, value);
        }
        /** @deprecated*/
        get has_grouped_license() {
            return pb_1.Message.getField(this, 8) != null;
        }
        static fromObject(data: {
            key_ids: Uint8Array[];
            content_id?: Uint8Array;
            crypto_period_index?: number;
            protection_scheme?: number;
            crypto_period_seconds?: number;
            type?: WidevinePsshData.Type;
            key_sequence?: number;
            group_ids: Uint8Array[];
            entitled_keys?: ReturnType<typeof WidevinePsshData.EntitledKey.prototype.toObject>[];
            video_feature?: string;
            algorithm?: WidevinePsshData.Algorithm;
            provider?: string;
            track_type?: string;
            policy?: string;
            grouped_license?: Uint8Array;
        }): WidevinePsshData {
            const message = new WidevinePsshData({
                key_ids: data.key_ids,
                group_ids: data.group_ids,
                entitled_keys: data.entitled_keys.map(item => WidevinePsshData.EntitledKey.fromObject(item))
            });
            if (data.content_id != null) {
                message.content_id = data.content_id;
            }
            if (data.crypto_period_index != null) {
                message.crypto_period_index = data.crypto_period_index;
            }
            if (data.protection_scheme != null) {
                message.protection_scheme = data.protection_scheme;
            }
            if (data.crypto_period_seconds != null) {
                message.crypto_period_seconds = data.crypto_period_seconds;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.key_sequence != null) {
                message.key_sequence = data.key_sequence;
            }
            if (data.video_feature != null) {
                message.video_feature = data.video_feature;
            }
            if (data.algorithm != null) {
                message.algorithm = data.algorithm;
            }
            if (data.provider != null) {
                message.provider = data.provider;
            }
            if (data.track_type != null) {
                message.track_type = data.track_type;
            }
            if (data.policy != null) {
                message.policy = data.policy;
            }
            if (data.grouped_license != null) {
                message.grouped_license = data.grouped_license;
            }
            return message;
        }
        toObject() {
            const data: {
                key_ids: Uint8Array[];
                content_id?: Uint8Array;
                crypto_period_index?: number;
                protection_scheme?: number;
                crypto_period_seconds?: number;
                type?: WidevinePsshData.Type;
                key_sequence?: number;
                group_ids: Uint8Array[];
                entitled_keys?: ReturnType<typeof WidevinePsshData.EntitledKey.prototype.toObject>[];
                video_feature?: string;
                algorithm?: WidevinePsshData.Algorithm;
                provider?: string;
                track_type?: string;
                policy?: string;
                grouped_license?: Uint8Array;
            } = {
                key_ids: this.key_ids,
                group_ids: this.group_ids
            };
            if (this.content_id != null) {
                data.content_id = this.content_id;
            }
            if (this.crypto_period_index != null) {
                data.crypto_period_index = this.crypto_period_index;
            }
            if (this.protection_scheme != null) {
                data.protection_scheme = this.protection_scheme;
            }
            if (this.crypto_period_seconds != null) {
                data.crypto_period_seconds = this.crypto_period_seconds;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.key_sequence != null) {
                data.key_sequence = this.key_sequence;
            }
            if (this.entitled_keys != null) {
                data.entitled_keys = this.entitled_keys.map((item: WidevinePsshData.EntitledKey) => item.toObject());
            }
            if (this.video_feature != null) {
                data.video_feature = this.video_feature;
            }
            if (this.algorithm != null) {
                data.algorithm = this.algorithm;
            }
            if (this.provider != null) {
                data.provider = this.provider;
            }
            if (this.track_type != null) {
                data.track_type = this.track_type;
            }
            if (this.policy != null) {
                data.policy = this.policy;
            }
            if (this.grouped_license != null) {
                data.grouped_license = this.grouped_license;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.key_ids.length)
                writer.writeRepeatedBytes(2, this.key_ids);
            if (this.has_content_id && this.content_id.length)
                writer.writeBytes(4, this.content_id);
            if (this.has_crypto_period_index)
                writer.writeUint32(7, this.crypto_period_index);
            if (this.has_protection_scheme)
                writer.writeUint32(9, this.protection_scheme);
            if (this.has_crypto_period_seconds)
                writer.writeUint32(10, this.crypto_period_seconds);
            if (this.has_type)
                writer.writeEnum(11, this.type);
            if (this.has_key_sequence)
                writer.writeUint32(12, this.key_sequence);
            if (this.group_ids.length)
                writer.writeRepeatedBytes(13, this.group_ids);
            if (this.entitled_keys.length)
                writer.writeRepeatedMessage(14, this.entitled_keys, (item: WidevinePsshData.EntitledKey) => item.serialize(writer));
            if (this.has_video_feature && this.video_feature.length)
                writer.writeString(15, this.video_feature);
            if (this.has_algorithm)
                writer.writeEnum(1, this.algorithm);
            if (this.has_provider && this.provider.length)
                writer.writeString(3, this.provider);
            if (this.has_track_type && this.track_type.length)
                writer.writeString(5, this.track_type);
            if (this.has_policy && this.policy.length)
                writer.writeString(6, this.policy);
            if (this.has_grouped_license && this.grouped_license.length)
                writer.writeBytes(8, this.grouped_license);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WidevinePsshData {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WidevinePsshData();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readBytes());
                        break;
                    case 4:
                        message.content_id = reader.readBytes();
                        break;
                    case 7:
                        message.crypto_period_index = reader.readUint32();
                        break;
                    case 9:
                        message.protection_scheme = reader.readUint32();
                        break;
                    case 10:
                        message.crypto_period_seconds = reader.readUint32();
                        break;
                    case 11:
                        message.type = reader.readEnum();
                        break;
                    case 12:
                        message.key_sequence = reader.readUint32();
                        break;
                    case 13:
                        pb_1.Message.addToRepeatedField(message, 13, reader.readBytes());
                        break;
                    case 14:
                        reader.readMessage(message.entitled_keys, () => pb_1.Message.addToRepeatedWrapperField(message, 14, WidevinePsshData.EntitledKey.deserialize(reader), WidevinePsshData.EntitledKey));
                        break;
                    case 15:
                        message.video_feature = reader.readString();
                        break;
                    case 1:
                        message.algorithm = reader.readEnum();
                        break;
                    case 3:
                        message.provider = reader.readString();
                        break;
                    case 5:
                        message.track_type = reader.readString();
                        break;
                    case 6:
                        message.policy = reader.readString();
                        break;
                    case 8:
                        message.grouped_license = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): WidevinePsshData {
            return WidevinePsshData.deserialize(bytes);
        }
    }
    export namespace WidevinePsshData {
        export enum Type {
            SINGLE = 0,
            ENTITLEMENT = 1,
            ENTITLED_KEY = 2
        }
        export enum Algorithm {
            UNENCRYPTED = 0,
            AESCTR = 1
        }
        export class EntitledKey extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                entitlement_key_id?: Uint8Array;
                key_id?: Uint8Array;
                key?: Uint8Array;
                iv?: Uint8Array;
                entitlement_key_size_bytes?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("entitlement_key_id" in data && data.entitlement_key_id != undefined) {
                        this.entitlement_key_id = data.entitlement_key_id;
                    }
                    if ("key_id" in data && data.key_id != undefined) {
                        this.key_id = data.key_id;
                    }
                    if ("key" in data && data.key != undefined) {
                        this.key = data.key;
                    }
                    if ("iv" in data && data.iv != undefined) {
                        this.iv = data.iv;
                    }
                    if ("entitlement_key_size_bytes" in data && data.entitlement_key_size_bytes != undefined) {
                        this.entitlement_key_size_bytes = data.entitlement_key_size_bytes;
                    }
                }
            }
            get entitlement_key_id() {
                return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
            }
            set entitlement_key_id(value: Uint8Array) {
                pb_1.Message.setField(this, 1, value);
            }
            get has_entitlement_key_id() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get key_id() {
                return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
            }
            set key_id(value: Uint8Array) {
                pb_1.Message.setField(this, 2, value);
            }
            get has_key_id() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get key() {
                return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
            }
            set key(value: Uint8Array) {
                pb_1.Message.setField(this, 3, value);
            }
            get has_key() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get iv() {
                return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array(0)) as Uint8Array;
            }
            set iv(value: Uint8Array) {
                pb_1.Message.setField(this, 4, value);
            }
            get has_iv() {
                return pb_1.Message.getField(this, 4) != null;
            }
            get entitlement_key_size_bytes() {
                return pb_1.Message.getFieldWithDefault(this, 5, 32) as number;
            }
            set entitlement_key_size_bytes(value: number) {
                pb_1.Message.setField(this, 5, value);
            }
            get has_entitlement_key_size_bytes() {
                return pb_1.Message.getField(this, 5) != null;
            }
            static fromObject(data: {
                entitlement_key_id?: Uint8Array;
                key_id?: Uint8Array;
                key?: Uint8Array;
                iv?: Uint8Array;
                entitlement_key_size_bytes?: number;
            }): EntitledKey {
                const message = new EntitledKey({});
                if (data.entitlement_key_id != null) {
                    message.entitlement_key_id = data.entitlement_key_id;
                }
                if (data.key_id != null) {
                    message.key_id = data.key_id;
                }
                if (data.key != null) {
                    message.key = data.key;
                }
                if (data.iv != null) {
                    message.iv = data.iv;
                }
                if (data.entitlement_key_size_bytes != null) {
                    message.entitlement_key_size_bytes = data.entitlement_key_size_bytes;
                }
                return message;
            }
            toObject() {
                const data: {
                    entitlement_key_id?: Uint8Array;
                    key_id?: Uint8Array;
                    key?: Uint8Array;
                    iv?: Uint8Array;
                    entitlement_key_size_bytes?: number;
                } = {};
                if (this.entitlement_key_id != null) {
                    data.entitlement_key_id = this.entitlement_key_id;
                }
                if (this.key_id != null) {
                    data.key_id = this.key_id;
                }
                if (this.key != null) {
                    data.key = this.key;
                }
                if (this.iv != null) {
                    data.iv = this.iv;
                }
                if (this.entitlement_key_size_bytes != null) {
                    data.entitlement_key_size_bytes = this.entitlement_key_size_bytes;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_entitlement_key_id && this.entitlement_key_id.length)
                    writer.writeBytes(1, this.entitlement_key_id);
                if (this.has_key_id && this.key_id.length)
                    writer.writeBytes(2, this.key_id);
                if (this.has_key && this.key.length)
                    writer.writeBytes(3, this.key);
                if (this.has_iv && this.iv.length)
                    writer.writeBytes(4, this.iv);
                if (this.has_entitlement_key_size_bytes)
                    writer.writeUint32(5, this.entitlement_key_size_bytes);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EntitledKey {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EntitledKey();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.entitlement_key_id = reader.readBytes();
                            break;
                        case 2:
                            message.key_id = reader.readBytes();
                            break;
                        case 3:
                            message.key = reader.readBytes();
                            break;
                        case 4:
                            message.iv = reader.readBytes();
                            break;
                        case 5:
                            message.entitlement_key_size_bytes = reader.readUint32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): EntitledKey {
                return EntitledKey.deserialize(bytes);
            }
        }
    }
    export class FileHashes extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            signer?: Uint8Array;
            signatures: FileHashes.Signature[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
                this.signatures = data.signatures;
            }
        }
        get signer() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set signer(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_signer() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get signatures() {
            return pb_1.Message.getRepeatedWrapperField(this, FileHashes.Signature, 2) as FileHashes.Signature[];
        }
        set signatures(value: FileHashes.Signature[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            signer?: Uint8Array;
            signatures?: ReturnType<typeof FileHashes.Signature.prototype.toObject>[];
        }): FileHashes {
            const message = new FileHashes({
                signatures: data.signatures.map(item => FileHashes.Signature.fromObject(item))
            });
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                signer?: Uint8Array;
                signatures?: ReturnType<typeof FileHashes.Signature.prototype.toObject>[];
            } = {};
            if (this.signer != null) {
                data.signer = this.signer;
            }
            if (this.signatures != null) {
                data.signatures = this.signatures.map((item: FileHashes.Signature) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_signer && this.signer.length)
                writer.writeBytes(1, this.signer);
            if (this.signatures.length)
                writer.writeRepeatedMessage(2, this.signatures, (item: FileHashes.Signature) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileHashes {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FileHashes();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.signer = reader.readBytes();
                        break;
                    case 2:
                        reader.readMessage(message.signatures, () => pb_1.Message.addToRepeatedWrapperField(message, 2, FileHashes.Signature.deserialize(reader), FileHashes.Signature));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FileHashes {
            return FileHashes.deserialize(bytes);
        }
    }
    export namespace FileHashes {
        export class Signature extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                filename?: string;
                test_signing?: boolean;
                SHA512Hash?: Uint8Array;
                main_exe?: boolean;
                signature?: Uint8Array;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("filename" in data && data.filename != undefined) {
                        this.filename = data.filename;
                    }
                    if ("test_signing" in data && data.test_signing != undefined) {
                        this.test_signing = data.test_signing;
                    }
                    if ("SHA512Hash" in data && data.SHA512Hash != undefined) {
                        this.SHA512Hash = data.SHA512Hash;
                    }
                    if ("main_exe" in data && data.main_exe != undefined) {
                        this.main_exe = data.main_exe;
                    }
                    if ("signature" in data && data.signature != undefined) {
                        this.signature = data.signature;
                    }
                }
            }
            get filename() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set filename(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get has_filename() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get test_signing() {
                return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
            }
            set test_signing(value: boolean) {
                pb_1.Message.setField(this, 2, value);
            }
            get has_test_signing() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get SHA512Hash() {
                return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
            }
            set SHA512Hash(value: Uint8Array) {
                pb_1.Message.setField(this, 3, value);
            }
            get has_SHA512Hash() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get main_exe() {
                return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
            }
            set main_exe(value: boolean) {
                pb_1.Message.setField(this, 4, value);
            }
            get has_main_exe() {
                return pb_1.Message.getField(this, 4) != null;
            }
            get signature() {
                return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
            }
            set signature(value: Uint8Array) {
                pb_1.Message.setField(this, 5, value);
            }
            get has_signature() {
                return pb_1.Message.getField(this, 5) != null;
            }
            static fromObject(data: {
                filename?: string;
                test_signing?: boolean;
                SHA512Hash?: Uint8Array;
                main_exe?: boolean;
                signature?: Uint8Array;
            }): Signature {
                const message = new Signature({});
                if (data.filename != null) {
                    message.filename = data.filename;
                }
                if (data.test_signing != null) {
                    message.test_signing = data.test_signing;
                }
                if (data.SHA512Hash != null) {
                    message.SHA512Hash = data.SHA512Hash;
                }
                if (data.main_exe != null) {
                    message.main_exe = data.main_exe;
                }
                if (data.signature != null) {
                    message.signature = data.signature;
                }
                return message;
            }
            toObject() {
                const data: {
                    filename?: string;
                    test_signing?: boolean;
                    SHA512Hash?: Uint8Array;
                    main_exe?: boolean;
                    signature?: Uint8Array;
                } = {};
                if (this.filename != null) {
                    data.filename = this.filename;
                }
                if (this.test_signing != null) {
                    data.test_signing = this.test_signing;
                }
                if (this.SHA512Hash != null) {
                    data.SHA512Hash = this.SHA512Hash;
                }
                if (this.main_exe != null) {
                    data.main_exe = this.main_exe;
                }
                if (this.signature != null) {
                    data.signature = this.signature;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_filename && this.filename.length)
                    writer.writeString(1, this.filename);
                if (this.has_test_signing)
                    writer.writeBool(2, this.test_signing);
                if (this.has_SHA512Hash && this.SHA512Hash.length)
                    writer.writeBytes(3, this.SHA512Hash);
                if (this.has_main_exe)
                    writer.writeBool(4, this.main_exe);
                if (this.has_signature && this.signature.length)
                    writer.writeBytes(5, this.signature);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Signature {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Signature();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.filename = reader.readString();
                            break;
                        case 2:
                            message.test_signing = reader.readBool();
                            break;
                        case 3:
                            message.SHA512Hash = reader.readBytes();
                            break;
                        case 4:
                            message.main_exe = reader.readBool();
                            break;
                        case 5:
                            message.signature = reader.readBytes();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Signature {
                return Signature.deserialize(bytes);
            }
        }
    }
}
